<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GTIRB: api-walkthrough.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GTIRB
   &#160;<span id="projectnumber">v1.10.4</span>
   </div>
   <div id="projectbrief">GrammaTech Intermediate Representation for Binaries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">api-walkthrough.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>Demonstrate many different elements of the GTIRB API.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="cpp/gtirb_8hpp.html">gtirb/gtirb.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/uuid/uuid_io.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="codeRef" href="cpp/namespacegtirb.html">gtirb</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="comment">// BEGIN</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// ### Initialization for AuxData usage</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// To make use of the auxiliary data mechanism, each schema that is</span></div>
<div class="line">  <span class="comment">// intended to be used must be registered with the API before doing</span></div>
<div class="line">  <span class="comment">// anything else with GTIRB. Typically, this is easiest to do as one</span></div>
<div class="line">  <span class="comment">// of the first steps in main().</span></div>
<div class="line">  AuxDataContainer::registerAuxDataType&lt;gtirb::schema::Types&gt;();</div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// ### Populating the IR</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// GTIRB representation objects have class `gtirb::IR`, and are created within</span></div>
<div class="line">  <span class="comment">// a context object (`gtirb::Context`). Freeing the context will also destroy</span></div>
<div class="line">  <span class="comment">// all the objects within it.</span></div>
<div class="line">  Context C;</div>
<div class="line">  <span class="keyword">auto</span>* Ir = <a name="a0"></a><a class="codeRef" href="cpp/classgtirb_1_1_i_r.html#a70cecfd85801a7d3273f109ce230331f">IR::Create</a>(C);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Every IR holds a set of modules (`gtirb::Module`).</span></div>
<div class="line">  <span class="keyword">auto</span>* M = <a name="a1"></a><a class="codeRef" href="cpp/classgtirb_1_1_module.html#aa0205979156944eb55f011e976194c18">Module::Create</a>(C, <span class="stringliteral">&quot;example&quot;</span>);</div>
<div class="line">  Ir-&gt;addModule(M);</div>
<div class="line">  <span class="comment">// Could also have written: auto* M = Ir-&gt;addModule(C);</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Every module holds a set of sections (`gtirb::Section`).</span></div>
<div class="line">  <span class="keyword">auto</span>* S = <a name="a2"></a><a class="codeRef" href="cpp/classgtirb_1_1_section.html#ab409db7dccee9aac92c00eb4a1a3b50d">Section::Create</a>(C, <span class="stringliteral">&quot;.text&quot;</span>);</div>
<div class="line">  M-&gt;addSection(S);</div>
<div class="line">  <span class="comment">// Could also have written: auto* S = M-&gt;addSection(C, &quot;.text&quot;);</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Every section has a set of byte intervals (`gtirb::ByteInterval`).</span></div>
<div class="line">  <span class="keyword">auto</span>* BI = <a name="a3"></a><a class="codeRef" href="cpp/classgtirb_1_1_byte_interval.html#a18925fb9dca97989ae51261de981deed">ByteInterval::Create</a>(C, Addr(2048), 466);</div>
<div class="line">  S-&gt;addByteInterval(BI);</div>
<div class="line">  <span class="comment">// Could also have written: auto* BI = S-&gt;addByteInterval(C, Addr(2048), 466);</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create some data objects. These only define the layout and do not directly</span></div>
<div class="line">  <span class="comment">// store any data.</span></div>
<div class="line">  <span class="keyword">auto</span>* D1 = <a name="a4"></a><a class="codeRef" href="cpp/classgtirb_1_1_data_block.html#a2be5c38fdd477e75c1ff8b0bafe89322">DataBlock::Create</a>(C, 6);</div>
<div class="line">  BI-&gt;addBlock(0, D1);</div>
<div class="line">  <span class="keyword">auto</span>* D2 = <a class="codeRef" href="cpp/classgtirb_1_1_data_block.html#a2be5c38fdd477e75c1ff8b0bafe89322">DataBlock::Create</a>(C, 2);</div>
<div class="line">  BI-&gt;addBlock(6, D2);</div>
<div class="line">  <span class="comment">// The actual data is stored in the blocks&#39; byte interval:</span></div>
<div class="line">  std::array&lt;uint8_t, 8&gt; Bytes{1, 0, 2, 0, 115, 116, 114, 108};</div>
<div class="line">  BI-&gt;insertBytes(<span class="keyword">const_cast&lt;</span><span class="keyword">const </span>ByteInterval*<span class="keyword">&gt;</span>(BI)-&gt;bytes_begin&lt;uint8_t&gt;(),</div>
<div class="line">                  Bytes.begin(), Bytes.end());</div>
<div class="line">  <span class="comment">// Symbols (`gtirb::Symbol`) associate a name with a block in the IR, such as</span></div>
<div class="line">  <span class="comment">// code blocks, data blocks, or proxy blocks. They can optionally store an</span></div>
<div class="line">  <span class="comment">// address instead.</span></div>
<div class="line">  [[maybe_unused]] <span class="keyword">auto</span>* Sym1 = M-&gt;addSymbol(<a name="a5"></a><a class="codeRef" href="cpp/classgtirb_1_1_symbol.html#acc479afbe5301e5210f7155104a46d0c">Symbol::Create</a>(C, D1, <span class="stringliteral">&quot;data1&quot;</span>));</div>
<div class="line">  [[maybe_unused]] <span class="keyword">auto</span>* Sym2 = M-&gt;addSymbol(<a class="codeRef" href="cpp/classgtirb_1_1_symbol.html#acc479afbe5301e5210f7155104a46d0c">Symbol::Create</a>(C, D2, <span class="stringliteral">&quot;data2&quot;</span>));</div>
<div class="line">  <span class="comment">// GTIRB can store multiple symbols with the same address or referent.</span></div>
<div class="line">  M-&gt;addSymbol(<a class="codeRef" href="cpp/classgtirb_1_1_symbol.html#acc479afbe5301e5210f7155104a46d0c">Symbol::Create</a>(C, D2, <span class="stringliteral">&quot;duplicateReferent&quot;</span>));</div>
<div class="line">  M-&gt;addSymbol(<a class="codeRef" href="cpp/classgtirb_1_1_symbol.html#acc479afbe5301e5210f7155104a46d0c">Symbol::Create</a>(C, Addr(2048), <span class="stringliteral">&quot;duplicateName&quot;</span>));</div>
<div class="line">  M-&gt;addSymbol(<a class="codeRef" href="cpp/classgtirb_1_1_symbol.html#acc479afbe5301e5210f7155104a46d0c">Symbol::Create</a>(C, Addr(4096), <span class="stringliteral">&quot;duplicateName&quot;</span>));</div>
<div class="line">  <span class="comment">// Basic blocks are stored as `gtirb::CodeBlock`s. Like data blocks, code</span></div>
<div class="line">  <span class="comment">// blocks reference data in a byte interval but do not directly hold any data</span></div>
<div class="line">  <span class="comment">// themselves. GTIRB does not directly represent instructions.</span></div>
<div class="line">  <span class="keyword">auto</span>* B1 = <a name="a6"></a><a class="codeRef" href="cpp/classgtirb_1_1_code_block.html#a766952bca15528b62280f72ad700d3fc">CodeBlock::Create</a>(C, 4);</div>
<div class="line">  BI-&gt;addBlock(12, B1);</div>
<div class="line">  <span class="keyword">auto</span>* B2 = <a class="codeRef" href="cpp/classgtirb_1_1_code_block.html#a766952bca15528b62280f72ad700d3fc">CodeBlock::Create</a>(C, 6);</div>
<div class="line">  BI-&gt;addBlock(16, B2);</div>
<div class="line">  <span class="comment">// GTIRB has an interprocedural control flow graph (`gtirb::CFG`) to track</span></div>
<div class="line">  <span class="comment">// relations between code blocks. The `CFG` can be populated with edges to</span></div>
<div class="line">  <span class="comment">// denote control flow.</span></div>
<div class="line">  <span class="keyword">auto</span>&amp; Cfg = Ir-&gt;getCFG();</div>
<div class="line">  <span class="keyword">auto</span> E = *<a name="a7"></a><a class="codeRef" href="cpp/group___c_f_g___g_r_o_u_p.html#ga8a20702c5f700c156869681cecb40e61">addEdge</a>(B1, B2, Cfg);</div>
<div class="line">  <span class="comment">// Edges can have labels, indicating the type of control flow:</span></div>
<div class="line">  Cfg[E] = std::make_tuple(<a name="a8"></a><a class="codeRef" href="cpp/group___c_f_g___g_r_o_u_p.html#gae81a540637128cef60bdd90806d28063a285401ebb613b552d7f7fdce68472211">ConditionalEdge::OnFalse</a>, <a name="a9"></a><a class="codeRef" href="cpp/group___c_f_g___g_r_o_u_p.html#ga0d810e653d6ebffa07b66e0d16b7ffd1a944cb3659575565b21c0a3bbdde5eb5a">DirectEdge::IsDirect</a>,</div>
<div class="line">                           <a name="a10"></a><a class="codeRef" href="cpp/group___c_f_g___g_r_o_u_p.html#ga5f75f57b6145b26ece90283a7b524b9da5d562a226f723ccf02b8c640f15f354b">EdgeType::Fallthrough</a>);</div>
<div class="line">  <span class="comment">// Symbolic expressions indicate that the value of a range of bytes depends on</span></div>
<div class="line">  <span class="comment">// the value of a symbol.</span></div>
<div class="line">  BI-&gt;addSymbolicExpression(14, SymAddrConst{0, Sym1});</div>
<div class="line">  <span class="comment">// Finally, auxiliary data can be used to store additional information at the</span></div>
<div class="line">  <span class="comment">// IR and module level. A `gtirb::AuxData` object can store integers, strings,</span></div>
<div class="line">  <span class="comment">// GTIRB types such as `gtirb::Addr` and `gtirb::UUID`, and various containers</span></div>
<div class="line">  <span class="comment">// over these types. There are predefined AuxData schema for you to use, but</span></div>
<div class="line">  <span class="comment">// you can also use your own custom AuxData schema. Here is use of a</span></div>
<div class="line">  <span class="comment">// predefined schema, `gtirb::schema::Types`:</span></div>
<div class="line">  M-&gt;addAuxData&lt;<a name="_a11"></a><a class="codeRef" href="cpp/structgtirb_1_1schema_1_1_types.html">gtirb::schema::Types</a>&gt;(</div>
<div class="line">      {{D1-&gt;getUUID(), <span class="stringliteral">&quot;string&quot;</span>}, {D2-&gt;getUUID(), <span class="stringliteral">&quot;uleb128&quot;</span>}});</div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// ### Querying the IR</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Symbols can be looked up by address or name.  Any number of symbols can</span></div>
<div class="line">  <span class="comment">// share an address or name, so be prepared to deal with multiple results.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; Sym : M-&gt;findSymbols(Addr(2054))) {</div>
<div class="line">    [[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span>&amp; _ = Sym;</div>
<div class="line">    assert(Sym.getAddress() == Addr(2054));</div>
<div class="line">    assert(Sym.getName() == <span class="stringliteral">&quot;data2&quot;</span> || Sym.getName() == <span class="stringliteral">&quot;duplicateReferent&quot;</span>);</div>
<div class="line">    assert(Sym.getReferent&lt;DataBlock&gt;() == <span class="keyword">nullptr</span> ||</div>
<div class="line">           Sym.getReferent&lt;DataBlock&gt;() == D2);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; Sym : M-&gt;findSymbols(<span class="stringliteral">&quot;duplicateName&quot;</span>)) {</div>
<div class="line">    [[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span>&amp; _ = Sym;</div>
<div class="line">    assert(Sym.getName() == <span class="stringliteral">&quot;duplicateName&quot;</span>);</div>
<div class="line">    assert(Sym.getAddress() == Addr(2048) || Sym.getAddress() == Addr(4096));</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Use a symbol&#39;s referent (either a Block or DataObject) to get more</span></div>
<div class="line">  <span class="comment">// information about the object to which the symbol points.</span></div>
<div class="line">  [[maybe_unused]] <span class="keyword">auto</span>* Referent = Sym1-&gt;getReferent&lt;DataBlock&gt;();</div>
<div class="line">  assert(Referent != <span class="keyword">nullptr</span>);</div>
<div class="line">  assert(Referent-&gt;getAddress() == Addr(2054));</div>
<div class="line">  assert(Referent-&gt;getSize() == 2);</div>
<div class="line">  assert(Referent-&gt;getByteInterval() == BI);</div>
<div class="line">  assert(Referent-&gt;getOffset() == 6);</div>
<div class="line">  <span class="comment">// Alternatively, blocks can be looked up by an address contained within the</span></div>
<div class="line">  <span class="comment">// object. Any number of blocks may overlap and contain an address, so be</span></div>
<div class="line">  <span class="comment">// prepared to deal with multiple results.</span></div>
<div class="line">  <span class="keyword">auto</span> Blocks = M-&gt;findBlocksAt(Addr(2048), Addr(4096));</div>
<div class="line">  assert(std::distance(Blocks.begin(), Blocks.end()) == 4);</div>
<div class="line">  <span class="comment">// The CFG uses</span></div>
<div class="line">  <span class="comment">// [boost::graph](https://www.boost.org/doc/libs/1_67_0/libs/graph/doc/).</span></div>
<div class="line">  <span class="comment">// GTIRB also provides a convenience function for iterating over blocks:</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; B : <a name="a12"></a><a class="codeRef" href="cpp/group___c_f_g___g_r_o_u_p.html#ga5039337a49b78d1fe67d47a61f8fcba9">blocks</a>(Cfg)) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Block at address &quot;</span> &lt;&lt; B.getAddress() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// To use boost::graph directly, you&#39;ll need to convert blocks into</span></div>
<div class="line">  <span class="comment">// `vertex_descriptor`s:</span></div>
<div class="line">  <span class="keyword">auto</span> [VerticesBegin, VerticesEnd] = boost::vertices(Cfg);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; Vertex :</div>
<div class="line">       boost::make_iterator_range(VerticesBegin, VerticesEnd)) {</div>
<div class="line">    <span class="keywordflow">if</span> (Cfg[Vertex] == B2) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;B2&#39;s vertex descriptor is: &quot;</span> &lt;&lt; Vertex &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// And once you have those, you can use `edge_descriptor`s to look up labels</span></div>
<div class="line">  <span class="comment">// and the source/target blocks:</span></div>
<div class="line">  <span class="keyword">auto</span> [EdgesBegin, EdgesEnd] = boost::edges(Cfg);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; Edge : boost::make_iterator_range(EdgesBegin, EdgesEnd)) {</div>
<div class="line">    <span class="keyword">auto</span> V1 = boost::source(Edge, Cfg);</div>
<div class="line">    <span class="keyword">auto</span> V2 = boost::target(Edge, Cfg);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Edge: &quot;</span> &lt;&lt; Cfg[V1] &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; Cfg[V2] &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> Label = *Cfg[Edge];</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Conditional? &quot;</span></div>
<div class="line">              &lt;&lt; (std::get&lt;ConditionalEdge&gt;(Label) == <a name="a13"></a><a class="codeRef" href="cpp/group___c_f_g___g_r_o_u_p.html#gae81a540637128cef60bdd90806d28063a9afa03f04e93fb31bfaab23cbeaa452d">ConditionalEdge::OnTrue</a>)</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Direct? &quot;</span></div>
<div class="line">              &lt;&lt; (std::get&lt;DirectEdge&gt;(Label) == <a class="codeRef" href="cpp/group___c_f_g___g_r_o_u_p.html#ga0d810e653d6ebffa07b66e0d16b7ffd1a944cb3659575565b21c0a3bbdde5eb5a">DirectEdge::IsDirect</a>)</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Fallthrough? &quot;</span></div>
<div class="line">              &lt;&lt; (std::get&lt;EdgeType&gt;(Label) == <a class="codeRef" href="cpp/group___c_f_g___g_r_o_u_p.html#ga5f75f57b6145b26ece90283a7b524b9da5d562a226f723ccf02b8c640f15f354b">EdgeType::Fallthrough</a>)</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Aux data can be retrieved based on the schema and queried upon.</span></div>
<div class="line">  <span class="keyword">auto</span>* typesMap = M-&gt;getAuxData&lt;<a class="codeRef" href="cpp/structgtirb_1_1schema_1_1_types.html">gtirb::schema::Types</a>&gt;();</div>
<div class="line">  <span class="keywordflow">if</span> (typesMap) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [DataBlockID, BlockType] : *typesMap) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Data block with UUID &quot;</span> &lt;&lt; DataBlockID &lt;&lt; <span class="stringliteral">&quot; is of type &quot;</span></div>
<div class="line">                &lt;&lt; BlockType &lt;&lt; <span class="stringliteral">&quot;!&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// ### Serialization</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Serialize IR to a file with `gtirb::IR::save`.</span></div>
<div class="line">  std::ofstream Out(<span class="stringliteral">&quot;path/to/file&quot;</span>);</div>
<div class="line">  Ir-&gt;save(Out);</div>
<div class="line">  <span class="comment">// Deserialize from a file with `gtirb::IR::load`.</span></div>
<div class="line">  std::ifstream In(<span class="stringliteral">&quot;path/to/file&quot;</span>);</div>
<div class="line">  [[maybe_unused]] <span class="keyword">auto</span>&amp; NewIR = *<a name="a14"></a><a class="codeRef" href="cpp/classgtirb_1_1_i_r.html#a3eb7d2a745085cd7c7ed37845ef57028">IR::load</a>(C, In);</div>
<div class="line">  <span class="comment">// END</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassgtirb_1_1_byte_interval_html_a18925fb9dca97989ae51261de981deed"><div class="ttname"><a href="cpp/classgtirb_1_1_byte_interval.html#a18925fb9dca97989ae51261de981deed">gtirb::ByteInterval::Create</a></div><div class="ttdeci">static ByteInterval * Create(Context &amp;C)</div></div>
<div class="ttc" id="aclassgtirb_1_1_code_block_html_a766952bca15528b62280f72ad700d3fc"><div class="ttname"><a href="cpp/classgtirb_1_1_code_block.html#a766952bca15528b62280f72ad700d3fc">gtirb::CodeBlock::Create</a></div><div class="ttdeci">static CodeBlock * Create(Context &amp;C)</div></div>
<div class="ttc" id="aclassgtirb_1_1_data_block_html_a2be5c38fdd477e75c1ff8b0bafe89322"><div class="ttname"><a href="cpp/classgtirb_1_1_data_block.html#a2be5c38fdd477e75c1ff8b0bafe89322">gtirb::DataBlock::Create</a></div><div class="ttdeci">static DataBlock * Create(Context &amp;C)</div></div>
<div class="ttc" id="aclassgtirb_1_1_i_r_html_a3eb7d2a745085cd7c7ed37845ef57028"><div class="ttname"><a href="cpp/classgtirb_1_1_i_r.html#a3eb7d2a745085cd7c7ed37845ef57028">gtirb::IR::load</a></div><div class="ttdeci">static ErrorOr&lt; IR * &gt; load(Context &amp;C, std::istream &amp;In)</div></div>
<div class="ttc" id="aclassgtirb_1_1_i_r_html_a70cecfd85801a7d3273f109ce230331f"><div class="ttname"><a href="cpp/classgtirb_1_1_i_r.html#a70cecfd85801a7d3273f109ce230331f">gtirb::IR::Create</a></div><div class="ttdeci">static IR * Create(Context &amp;C)</div></div>
<div class="ttc" id="aclassgtirb_1_1_module_html_aa0205979156944eb55f011e976194c18"><div class="ttname"><a href="cpp/classgtirb_1_1_module.html#aa0205979156944eb55f011e976194c18">gtirb::Module::Create</a></div><div class="ttdeci">static Module * Create(Context &amp;C, const std::string &amp;Name)</div></div>
<div class="ttc" id="aclassgtirb_1_1_section_html_ab409db7dccee9aac92c00eb4a1a3b50d"><div class="ttname"><a href="cpp/classgtirb_1_1_section.html#ab409db7dccee9aac92c00eb4a1a3b50d">gtirb::Section::Create</a></div><div class="ttdeci">static Section * Create(Context &amp;C)</div></div>
<div class="ttc" id="aclassgtirb_1_1_symbol_html_acc479afbe5301e5210f7155104a46d0c"><div class="ttname"><a href="cpp/classgtirb_1_1_symbol.html#acc479afbe5301e5210f7155104a46d0c">gtirb::Symbol::Create</a></div><div class="ttdeci">static Symbol * Create(Context &amp;C)</div></div>
<div class="ttc" id="agroup___c_f_g___g_r_o_u_p_html_ga0d810e653d6ebffa07b66e0d16b7ffd1a944cb3659575565b21c0a3bbdde5eb5a"><div class="ttname"><a href="cpp/group___c_f_g___g_r_o_u_p.html#ga0d810e653d6ebffa07b66e0d16b7ffd1a944cb3659575565b21c0a3bbdde5eb5a">gtirb::DirectEdge::IsDirect</a></div><div class="ttdeci">@ IsDirect</div></div>
<div class="ttc" id="agroup___c_f_g___g_r_o_u_p_html_ga5039337a49b78d1fe67d47a61f8fcba9"><div class="ttname"><a href="cpp/group___c_f_g___g_r_o_u_p.html#ga5039337a49b78d1fe67d47a61f8fcba9">gtirb::blocks</a></div><div class="ttdeci">GTIRB_EXPORT_API boost::iterator_range&lt; block_iterator &gt; blocks(CFG &amp;Cfg)</div></div>
<div class="ttc" id="agroup___c_f_g___g_r_o_u_p_html_ga5f75f57b6145b26ece90283a7b524b9da5d562a226f723ccf02b8c640f15f354b"><div class="ttname"><a href="cpp/group___c_f_g___g_r_o_u_p.html#ga5f75f57b6145b26ece90283a7b524b9da5d562a226f723ccf02b8c640f15f354b">gtirb::EdgeType::Fallthrough</a></div><div class="ttdeci">@ Fallthrough</div></div>
<div class="ttc" id="agroup___c_f_g___g_r_o_u_p_html_ga8a20702c5f700c156869681cecb40e61"><div class="ttname"><a href="cpp/group___c_f_g___g_r_o_u_p.html#ga8a20702c5f700c156869681cecb40e61">gtirb::addEdge</a></div><div class="ttdeci">GTIRB_EXPORT_API std::optional&lt; CFG::edge_descriptor &gt; addEdge(const CfgNode *From, const CfgNode *To, CFG &amp;Cfg)</div></div>
<div class="ttc" id="agroup___c_f_g___g_r_o_u_p_html_gae81a540637128cef60bdd90806d28063a285401ebb613b552d7f7fdce68472211"><div class="ttname"><a href="cpp/group___c_f_g___g_r_o_u_p.html#gae81a540637128cef60bdd90806d28063a285401ebb613b552d7f7fdce68472211">gtirb::ConditionalEdge::OnFalse</a></div><div class="ttdeci">@ OnFalse</div></div>
<div class="ttc" id="agroup___c_f_g___g_r_o_u_p_html_gae81a540637128cef60bdd90806d28063a9afa03f04e93fb31bfaab23cbeaa452d"><div class="ttname"><a href="cpp/group___c_f_g___g_r_o_u_p.html#gae81a540637128cef60bdd90806d28063a9afa03f04e93fb31bfaab23cbeaa452d">gtirb::ConditionalEdge::OnTrue</a></div><div class="ttdeci">@ OnTrue</div></div>
<div class="ttc" id="agtirb_8hpp.html_html"><div class="ttname"><a href="cpp/gtirb_8hpp.html">gtirb.hpp</a></div></div>
<div class="ttc" id="anamespacegtirb_html"><div class="ttname"><a href="cpp/namespacegtirb.html">gtirb</a></div></div>
<div class="ttc" id="astructgtirb_1_1schema_1_1_types_html"><div class="ttname"><a href="cpp/structgtirb_1_1schema_1_1_types.html">gtirb::schema::Types</a></div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
