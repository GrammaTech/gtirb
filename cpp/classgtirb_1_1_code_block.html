<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GTIRB: gtirb::CodeBlock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GTIRB
   &#160;<span id="projectnumber">v1.10.4</span>
   </div>
   <div id="projectbrief">GrammaTech Intermediate Representation for Binaries: C++ API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegtirb.html">gtirb</a></li><li class="navelem"><a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgtirb_1_1_code_block-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gtirb::CodeBlock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A basic block.  
 <a href="classgtirb_1_1_code_block.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_code_block_8hpp_source.html">CodeBlock.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for gtirb::CodeBlock:</div>
<div class="dyncontent">
<div class="center"><img src="classgtirb_1_1_code_block__inherit__graph.png" border="0" usemap="#agtirb_1_1_code_block_inherit__map" alt="Inheritance graph"/></div>
<map name="agtirb_1_1_code_block_inherit__map" id="agtirb_1_1_code_block_inherit__map">
<area shape="rect" title="A basic block." alt="" coords="5,155,124,181"/>
<area shape="rect" href="classgtirb_1_1_cfg_node.html" title="Represents the base of types that can be inserted into the CFG." alt="" coords="11,80,118,107"/>
<area shape="rect" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy." alt="" coords="21,5,108,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for gtirb::CodeBlock:</div>
<div class="dyncontent">
<div class="center"><img src="classgtirb_1_1_code_block__coll__graph.png" border="0" usemap="#agtirb_1_1_code_block_coll__map" alt="Collaboration graph"/></div>
<map name="agtirb_1_1_code_block_coll__map" id="agtirb_1_1_code_block_coll__map">
<area shape="rect" title="A basic block." alt="" coords="5,155,124,181"/>
<area shape="rect" href="classgtirb_1_1_cfg_node.html" title="Represents the base of types that can be inserted into the CFG." alt="" coords="11,80,118,107"/>
<area shape="rect" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy." alt="" coords="21,5,108,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa84899dc4775eee1bbed024c17fce84d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa84899dc4775eee1bbed024c17fce84d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">bytes_iterator</a> = <a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">ByteInterval::bytes_iterator</a>&lt; T &gt;</td></tr>
<tr class="memdesc:aa84899dc4775eee1bbed024c17fce84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over bytes in this block.  <a href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">More...</a><br /></td></tr>
<tr class="separator:aa84899dc4775eee1bbed024c17fce84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c1b53a20f8143f5b3472dcce9d0613"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8c1b53a20f8143f5b3472dcce9d0613"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#ae8c1b53a20f8143f5b3472dcce9d0613">bytes_range</a> = <a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">ByteInterval::bytes_range</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ae8c1b53a20f8143f5b3472dcce9d0613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range over bytes in this block.  <a href="classgtirb_1_1_code_block.html#ae8c1b53a20f8143f5b3472dcce9d0613">More...</a><br /></td></tr>
<tr class="separator:ae8c1b53a20f8143f5b3472dcce9d0613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042872c0a44303e41c5389b5da0855af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a042872c0a44303e41c5389b5da0855af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">const_bytes_iterator</a> = <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">ByteInterval::const_bytes_iterator</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a042872c0a44303e41c5389b5da0855af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over bytes in this block.  <a href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">More...</a><br /></td></tr>
<tr class="separator:a042872c0a44303e41c5389b5da0855af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1f0b88e150263aaa02bb05506515bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a1f0b88e150263aaa02bb05506515bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a3a1f0b88e150263aaa02bb05506515bd">const_bytes_range</a> = <a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">ByteInterval::const_bytes_range</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a3a1f0b88e150263aaa02bb05506515bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const range over bytes in this block.  <a href="classgtirb_1_1_code_block.html#a3a1f0b88e150263aaa02bb05506515bd">More...</a><br /></td></tr>
<tr class="separator:a3a1f0b88e150263aaa02bb05506515bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51971c65c49bd9e3900bd17a6d37449d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51971c65c49bd9e3900bd17a6d37449d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#ae8c1b53a20f8143f5b3472dcce9d0613">bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a51971c65c49bd9e3900bd17a6d37449d">bytes</a> ()</td></tr>
<tr class="memdesc:a51971c65c49bd9e3900bd17a6d37449d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of the bytes in this block.  <a href="classgtirb_1_1_code_block.html#a51971c65c49bd9e3900bd17a6d37449d">More...</a><br /></td></tr>
<tr class="separator:a51971c65c49bd9e3900bd17a6d37449d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99375f1bb4c683cd83f04f90071a2f65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99375f1bb4c683cd83f04f90071a2f65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#a3a1f0b88e150263aaa02bb05506515bd">const_bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a99375f1bb4c683cd83f04f90071a2f65">bytes</a> () const</td></tr>
<tr class="memdesc:a99375f1bb4c683cd83f04f90071a2f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of the bytes in this block.  <a href="classgtirb_1_1_code_block.html#a99375f1bb4c683cd83f04f90071a2f65">More...</a><br /></td></tr>
<tr class="separator:a99375f1bb4c683cd83f04f90071a2f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2669909af6dd4639a040b6284501d7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2669909af6dd4639a040b6284501d7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#ae8c1b53a20f8143f5b3472dcce9d0613">bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#ab2669909af6dd4639a040b6284501d7b">bytes</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:ab2669909af6dd4639a040b6284501d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of the bytes in this block.  <a href="classgtirb_1_1_code_block.html#ab2669909af6dd4639a040b6284501d7b">More...</a><br /></td></tr>
<tr class="separator:ab2669909af6dd4639a040b6284501d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f898de7462ce9032fe87d4d2b308e49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f898de7462ce9032fe87d4d2b308e49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#a3a1f0b88e150263aaa02bb05506515bd">const_bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a6f898de7462ce9032fe87d4d2b308e49">bytes</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native) const</td></tr>
<tr class="memdesc:a6f898de7462ce9032fe87d4d2b308e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of the bytes in this block.  <a href="classgtirb_1_1_code_block.html#a6f898de7462ce9032fe87d4d2b308e49">More...</a><br /></td></tr>
<tr class="separator:a6f898de7462ce9032fe87d4d2b308e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7508018988d4b3e134d72f2543e33f20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7508018988d4b3e134d72f2543e33f20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a7508018988d4b3e134d72f2543e33f20">bytes_begin</a> ()</td></tr>
<tr class="memdesc:a7508018988d4b3e134d72f2543e33f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first byte in this block.  <a href="classgtirb_1_1_code_block.html#a7508018988d4b3e134d72f2543e33f20">More...</a><br /></td></tr>
<tr class="separator:a7508018988d4b3e134d72f2543e33f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb47649b728f6bacf10dc576b526c2f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb47649b728f6bacf10dc576b526c2f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#adb47649b728f6bacf10dc576b526c2f2">bytes_begin</a> () const</td></tr>
<tr class="memdesc:adb47649b728f6bacf10dc576b526c2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first byte in this block.  <a href="classgtirb_1_1_code_block.html#adb47649b728f6bacf10dc576b526c2f2">More...</a><br /></td></tr>
<tr class="separator:adb47649b728f6bacf10dc576b526c2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2087824a6023dd1a7920165e73eeb226"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2087824a6023dd1a7920165e73eeb226"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a2087824a6023dd1a7920165e73eeb226">bytes_begin</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:a2087824a6023dd1a7920165e73eeb226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first byte in this block.  <a href="classgtirb_1_1_code_block.html#a2087824a6023dd1a7920165e73eeb226">More...</a><br /></td></tr>
<tr class="separator:a2087824a6023dd1a7920165e73eeb226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6e9f2112e32576d691fd48b5438871"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd6e9f2112e32576d691fd48b5438871"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#abd6e9f2112e32576d691fd48b5438871">bytes_begin</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native) const</td></tr>
<tr class="memdesc:abd6e9f2112e32576d691fd48b5438871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first byte in this block.  <a href="classgtirb_1_1_code_block.html#abd6e9f2112e32576d691fd48b5438871">More...</a><br /></td></tr>
<tr class="separator:abd6e9f2112e32576d691fd48b5438871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf571e1f430ea3e2aafe4f726368add3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf571e1f430ea3e2aafe4f726368add3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#acf571e1f430ea3e2aafe4f726368add3">bytes_end</a> ()</td></tr>
<tr class="memdesc:acf571e1f430ea3e2aafe4f726368add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last byte in this block.  <a href="classgtirb_1_1_code_block.html#acf571e1f430ea3e2aafe4f726368add3">More...</a><br /></td></tr>
<tr class="separator:acf571e1f430ea3e2aafe4f726368add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d514875060e4c15a47dbfac7736f5dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d514875060e4c15a47dbfac7736f5dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a1d514875060e4c15a47dbfac7736f5dc">bytes_end</a> () const</td></tr>
<tr class="memdesc:a1d514875060e4c15a47dbfac7736f5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last byte in this block.  <a href="classgtirb_1_1_code_block.html#a1d514875060e4c15a47dbfac7736f5dc">More...</a><br /></td></tr>
<tr class="separator:a1d514875060e4c15a47dbfac7736f5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01298168d637e408cf1909744150755f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01298168d637e408cf1909744150755f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a01298168d637e408cf1909744150755f">bytes_end</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:a01298168d637e408cf1909744150755f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last byte in this block.  <a href="classgtirb_1_1_code_block.html#a01298168d637e408cf1909744150755f">More...</a><br /></td></tr>
<tr class="separator:a01298168d637e408cf1909744150755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e592e516a736641eadda2d81bf08f78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e592e516a736641eadda2d81bf08f78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a2e592e516a736641eadda2d81bf08f78">bytes_end</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native) const</td></tr>
<tr class="memdesc:a2e592e516a736641eadda2d81bf08f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last byte in this block.  <a href="classgtirb_1_1_code_block.html#a2e592e516a736641eadda2d81bf08f78">More...</a><br /></td></tr>
<tr class="separator:a2e592e516a736641eadda2d81bf08f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b422fc7b8432677c0ba0fde33064f7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classgtirb_1_1_addr.html">Addr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#ae4b422fc7b8432677c0ba0fde33064f7">getAddress</a> () const</td></tr>
<tr class="memdesc:ae4b422fc7b8432677c0ba0fde33064f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of this block, if present. See <a class="el" href="classgtirb_1_1_byte_interval.html#aaf13ececea7d2b943402feeb4f1aae35">ByteInterval::getAddress</a> for details on why this address may not be present.  <a href="classgtirb_1_1_code_block.html#ae4b422fc7b8432677c0ba0fde33064f7">More...</a><br /></td></tr>
<tr class="separator:ae4b422fc7b8432677c0ba0fde33064f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb3d8fccb8ce8b9cfc1678ebcad05b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#adcb3d8fccb8ce8b9cfc1678ebcad05b0">getByteInterval</a> ()</td></tr>
<tr class="memdesc:adcb3d8fccb8ce8b9cfc1678ebcad05b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to.  <a href="classgtirb_1_1_code_block.html#adcb3d8fccb8ce8b9cfc1678ebcad05b0">More...</a><br /></td></tr>
<tr class="separator:adcb3d8fccb8ce8b9cfc1678ebcad05b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724aec9ad4956998877668c7e0cd3885"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a724aec9ad4956998877668c7e0cd3885">getByteInterval</a> () const</td></tr>
<tr class="memdesc:a724aec9ad4956998877668c7e0cd3885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to.  <a href="classgtirb_1_1_code_block.html#a724aec9ad4956998877668c7e0cd3885">More...</a><br /></td></tr>
<tr class="separator:a724aec9ad4956998877668c7e0cd3885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143f2f0de1998148d2cf5c5bac34d508"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a143f2f0de1998148d2cf5c5bac34d508">getDecodeMode</a> () const</td></tr>
<tr class="memdesc:a143f2f0de1998148d2cf5c5bac34d508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the decode mode from a <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>.  <a href="classgtirb_1_1_code_block.html#a143f2f0de1998148d2cf5c5bac34d508">More...</a><br /></td></tr>
<tr class="separator:a143f2f0de1998148d2cf5c5bac34d508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7b31450f8be4854d4676222593c176"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a9c7b31450f8be4854d4676222593c176">getOffset</a> () const</td></tr>
<tr class="memdesc:a9c7b31450f8be4854d4676222593c176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset from the beginning of the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to.  <a href="classgtirb_1_1_code_block.html#a9c7b31450f8be4854d4676222593c176">More...</a><br /></td></tr>
<tr class="separator:a9c7b31450f8be4854d4676222593c176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012484e3c79c8a8758533f92506058b4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a012484e3c79c8a8758533f92506058b4">getSize</a> () const</td></tr>
<tr class="memdesc:a012484e3c79c8a8758533f92506058b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size from a <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>.  <a href="classgtirb_1_1_code_block.html#a012484e3c79c8a8758533f92506058b4">More...</a><br /></td></tr>
<tr class="separator:a012484e3c79c8a8758533f92506058b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675d80fc346a55c24e54d0c1a7be4e24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a675d80fc346a55c24e54d0c1a7be4e24"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a675d80fc346a55c24e54d0c1a7be4e24">rawBytes</a> ()</td></tr>
<tr class="memdesc:a675d80fc346a55c24e54d0c1a7be4e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw data underlying this block's byte vector.  <a href="classgtirb_1_1_code_block.html#a675d80fc346a55c24e54d0c1a7be4e24">More...</a><br /></td></tr>
<tr class="separator:a675d80fc346a55c24e54d0c1a7be4e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4494bd1af45efde9831f9e8e095030"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae4494bd1af45efde9831f9e8e095030"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#aae4494bd1af45efde9831f9e8e095030">rawBytes</a> () const</td></tr>
<tr class="memdesc:aae4494bd1af45efde9831f9e8e095030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw data underlying this block's byte vector.  <a href="classgtirb_1_1_code_block.html#aae4494bd1af45efde9831f9e8e095030">More...</a><br /></td></tr>
<tr class="separator:aae4494bd1af45efde9831f9e8e095030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a281e633e076794f0cca587a99b5f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a54a281e633e076794f0cca587a99b5f0">setDecodeMode</a> (uint64_t DM)</td></tr>
<tr class="memdesc:a54a281e633e076794f0cca587a99b5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the decode mode of this block.  <a href="classgtirb_1_1_code_block.html#a54a281e633e076794f0cca587a99b5f0">More...</a><br /></td></tr>
<tr class="separator:a54a281e633e076794f0cca587a99b5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e4316eb57d451ee5028a6c8dbdd286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a18e4316eb57d451ee5028a6c8dbdd286">setSize</a> (uint64_t S)</td></tr>
<tr class="memdesc:a18e4316eb57d451ee5028a6c8dbdd286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of this block.  <a href="classgtirb_1_1_code_block.html#a18e4316eb57d451ee5028a6c8dbdd286">More...</a><br /></td></tr>
<tr class="separator:a18e4316eb57d451ee5028a6c8dbdd286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgtirb_1_1_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgtirb_1_1_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgtirb_1_1_node.html">gtirb::Node</a></td></tr>
<tr class="memitem:a36a7eb184c437e329cd6628abd7981a3 inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a36a7eb184c437e329cd6628abd7981a3">Node</a> (const <a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;)=delete</td></tr>
<tr class="memdesc:a36a7eb184c437e329cd6628abd7981a3 inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying Nodes is explicitly disabled.  <a href="classgtirb_1_1_node.html#a36a7eb184c437e329cd6628abd7981a3">More...</a><br /></td></tr>
<tr class="separator:a36a7eb184c437e329cd6628abd7981a3 inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3e3cc413be907d848fbd839acd937c inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a9b3e3cc413be907d848fbd839acd937c">Node</a> (<a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a9b3e3cc413be907d848fbd839acd937c inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructing Nodes is explicitly disabled.  <a href="classgtirb_1_1_node.html#a9b3e3cc413be907d848fbd839acd937c">More...</a><br /></td></tr>
<tr class="separator:a9b3e3cc413be907d848fbd839acd937c inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2198c2f14d4b1bc01dfe50b0c10bdfed inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a2198c2f14d4b1bc01dfe50b0c10bdfed">~Node</a> () noexcept</td></tr>
<tr class="memdesc:a2198c2f14d4b1bc01dfe50b0c10bdfed inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up resources no longer needed by the <a class="el" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy.">Node</a> object.  <a href="classgtirb_1_1_node.html#a2198c2f14d4b1bc01dfe50b0c10bdfed">More...</a><br /></td></tr>
<tr class="separator:a2198c2f14d4b1bc01dfe50b0c10bdfed inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c1f7fbac43e778445e6a710a401700 inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a05c1f7fbac43e778445e6a710a401700">getUUID</a> () const</td></tr>
<tr class="memdesc:a05c1f7fbac43e778445e6a710a401700 inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Universally Unique ID (UUID) for <code>this</code>.  <a href="classgtirb_1_1_node.html#a05c1f7fbac43e778445e6a710a401700">More...</a><br /></td></tr>
<tr class="separator:a05c1f7fbac43e778445e6a710a401700 inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada843ff6ad535a3f82650a4f580255e3 inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#ada843ff6ad535a3f82650a4f580255e3">operator=</a> (const <a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;)=delete</td></tr>
<tr class="memdesc:ada843ff6ad535a3f82650a4f580255e3 inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying Nodes is explicilty disabled.  <a href="classgtirb_1_1_node.html#ada843ff6ad535a3f82650a4f580255e3">More...</a><br /></td></tr>
<tr class="separator:ada843ff6ad535a3f82650a4f580255e3 inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ffe7e5d11d133b6a77a22ffc208e1c inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#aa2ffe7e5d11d133b6a77a22ffc208e1c">operator=</a> (<a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:aa2ffe7e5d11d133b6a77a22ffc208e1c inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigning Nodes is explicilty disabled.  <a href="classgtirb_1_1_node.html#aa2ffe7e5d11d133b6a77a22ffc208e1c">More...</a><br /></td></tr>
<tr class="separator:aa2ffe7e5d11d133b6a77a22ffc208e1c inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a766952bca15528b62280f72ad700d3fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a766952bca15528b62280f72ad700d3fc">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C)</td></tr>
<tr class="memdesc:a766952bca15528b62280f72ad700d3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an unitialized <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a> object.  <a href="classgtirb_1_1_code_block.html#a766952bca15528b62280f72ad700d3fc">More...</a><br /></td></tr>
<tr class="separator:a766952bca15528b62280f72ad700d3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718bb0acbd3e2dcfc1ea0dc8068ebf57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a718bb0acbd3e2dcfc1ea0dc8068ebf57">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, uint64_t Size, uint64_t DecodeMode=0)</td></tr>
<tr class="memdesc:a718bb0acbd3e2dcfc1ea0dc8068ebf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a> object.  <a href="classgtirb_1_1_code_block.html#a718bb0acbd3e2dcfc1ea0dc8068ebf57">More...</a><br /></td></tr>
<tr class="separator:a718bb0acbd3e2dcfc1ea0dc8068ebf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classgtirb_1_1_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classgtirb_1_1_node')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classgtirb_1_1_node.html">gtirb::Node</a></td></tr>
<tr class="memitem:ab34e75309d3cdbae6ae783483152bf1c inherit pub_static_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#ab34e75309d3cdbae6ae783483152bf1c">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C)</td></tr>
<tr class="memdesc:ab34e75309d3cdbae6ae783483152bf1c inherit pub_static_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy.">Node</a> object in its default state.  <a href="classgtirb_1_1_node.html#ab34e75309d3cdbae6ae783483152bf1c">More...</a><br /></td></tr>
<tr class="separator:ab34e75309d3cdbae6ae783483152bf1c inherit pub_static_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04cfa2271347cdeb3a547f829141380 inherit pub_static_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classgtirb_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#ad04cfa2271347cdeb3a547f829141380">getByUUID</a> (const <a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;Uuid)</td></tr>
<tr class="memdesc:ad04cfa2271347cdeb3a547f829141380 inherit pub_static_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a node by its UUID.  <a href="classgtirb_1_1_node.html#ad04cfa2271347cdeb3a547f829141380">More...</a><br /></td></tr>
<tr class="separator:ad04cfa2271347cdeb3a547f829141380 inherit pub_static_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea06820c30b4b70b97b317877e86d17 inherit pub_static_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#abea06820c30b4b70b97b317877e86d17">getByUUID</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;Uuid)</td></tr>
<tr class="memdesc:abea06820c30b4b70b97b317877e86d17 inherit pub_static_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a node by its UUID.  <a href="classgtirb_1_1_node.html#abea06820c30b4b70b97b317877e86d17">More...</a><br /></td></tr>
<tr class="separator:abea06820c30b4b70b97b317877e86d17 inherit pub_static_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2ed0265c4b443cda27a241352629170f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#a2ed0265c4b443cda27a241352629170f">ByteInterval</a></td></tr>
<tr class="separator:a2ed0265c4b443cda27a241352629170f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26c806e60ca4a0547680edb68f6e39b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#ac26c806e60ca4a0547680edb68f6e39b">Context</a></td></tr>
<tr class="separator:ac26c806e60ca4a0547680edb68f6e39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7995861301f2eefb390acea47c34a9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_code_block.html#aca7995861301f2eefb390acea47c34a9">SerializationTestHarness</a></td></tr>
<tr class="separator:aca7995861301f2eefb390acea47c34a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classgtirb_1_1_cfg_node"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classgtirb_1_1_cfg_node')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classgtirb_1_1_cfg_node.html">gtirb::CfgNode</a></td></tr>
<tr class="memitem:a924b02fc21b48184569ea41d6898a50a inherit pro_methods_classgtirb_1_1_cfg_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_cfg_node.html#a924b02fc21b48184569ea41d6898a50a">CfgNode</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, Kind Knd)</td></tr>
<tr class="separator:a924b02fc21b48184569ea41d6898a50a inherit pro_methods_classgtirb_1_1_cfg_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcd5f4e6d7ff1170726e7298786b87b inherit pro_methods_classgtirb_1_1_cfg_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_cfg_node.html#abdcd5f4e6d7ff1170726e7298786b87b">CfgNode</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, Kind Knd, const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;U)</td></tr>
<tr class="separator:abdcd5f4e6d7ff1170726e7298786b87b inherit pro_methods_classgtirb_1_1_cfg_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A basic block. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_f_g___g_r_o_u_p.html">Control Flow Graphs (CFGs)</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa84899dc4775eee1bbed024c17fce84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84899dc4775eee1bbed024c17fce84d">&#9670;&nbsp;</a></span>bytes_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">gtirb::CodeBlock::bytes_iterator</a> =  <a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">ByteInterval::bytes_iterator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over bytes in this block. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8c1b53a20f8143f5b3472dcce9d0613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c1b53a20f8143f5b3472dcce9d0613">&#9670;&nbsp;</a></span>bytes_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_code_block.html#ae8c1b53a20f8143f5b3472dcce9d0613">gtirb::CodeBlock::bytes_range</a> =  <a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">ByteInterval::bytes_range</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range over bytes in this block. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a042872c0a44303e41c5389b5da0855af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042872c0a44303e41c5389b5da0855af">&#9670;&nbsp;</a></span>const_bytes_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">gtirb::CodeBlock::const_bytes_iterator</a> =  <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">ByteInterval::const_bytes_iterator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator over bytes in this block. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a1f0b88e150263aaa02bb05506515bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1f0b88e150263aaa02bb05506515bd">&#9670;&nbsp;</a></span>const_bytes_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_code_block.html#a3a1f0b88e150263aaa02bb05506515bd">gtirb::CodeBlock::const_bytes_range</a> =  <a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">ByteInterval::const_bytes_range</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const range over bytes in this block. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a51971c65c49bd9e3900bd17a6d37449d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51971c65c49bd9e3900bd17a6d37449d">&#9670;&nbsp;</a></span>bytes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#ae8c1b53a20f8143f5b3472dcce9d0613">bytes_range</a>&lt;T&gt; gtirb::CodeBlock::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of the bytes in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99375f1bb4c683cd83f04f90071a2f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99375f1bb4c683cd83f04f90071a2f65">&#9670;&nbsp;</a></span>bytes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#a3a1f0b88e150263aaa02bb05506515bd">const_bytes_range</a>&lt;T&gt; gtirb::CodeBlock::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of the bytes in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2669909af6dd4639a040b6284501d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2669909af6dd4639a040b6284501d7b">&#9670;&nbsp;</a></span>bytes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#ae8c1b53a20f8143f5b3472dcce9d0613">bytes_range</a>&lt;T&gt; gtirb::CodeBlock::bytes </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of the bytes in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f898de7462ce9032fe87d4d2b308e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f898de7462ce9032fe87d4d2b308e49">&#9670;&nbsp;</a></span>bytes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#a3a1f0b88e150263aaa02bb05506515bd">const_bytes_range</a>&lt;T&gt; gtirb::CodeBlock::bytes </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of the bytes in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7508018988d4b3e134d72f2543e33f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7508018988d4b3e134d72f2543e33f20">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">bytes_iterator</a>&lt;T&gt; gtirb::CodeBlock::bytes_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb47649b728f6bacf10dc576b526c2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb47649b728f6bacf10dc576b526c2f2">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">const_bytes_iterator</a>&lt;T&gt; gtirb::CodeBlock::bytes_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2087824a6023dd1a7920165e73eeb226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2087824a6023dd1a7920165e73eeb226">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">bytes_iterator</a>&lt;T&gt; gtirb::CodeBlock::bytes_begin </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd6e9f2112e32576d691fd48b5438871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6e9f2112e32576d691fd48b5438871">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">const_bytes_iterator</a>&lt;T&gt; gtirb::CodeBlock::bytes_begin </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf571e1f430ea3e2aafe4f726368add3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf571e1f430ea3e2aafe4f726368add3">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">bytes_iterator</a>&lt;T&gt; gtirb::CodeBlock::bytes_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d514875060e4c15a47dbfac7736f5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d514875060e4c15a47dbfac7736f5dc">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">const_bytes_iterator</a>&lt;T&gt; gtirb::CodeBlock::bytes_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01298168d637e408cf1909744150755f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01298168d637e408cf1909744150755f">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#aa84899dc4775eee1bbed024c17fce84d">bytes_iterator</a>&lt;T&gt; gtirb::CodeBlock::bytes_end </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e592e516a736641eadda2d81bf08f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e592e516a736641eadda2d81bf08f78">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_code_block.html#a042872c0a44303e41c5389b5da0855af">const_bytes_iterator</a>&lt;T&gt; gtirb::CodeBlock::bytes_end </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a766952bca15528b62280f72ad700d3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766952bca15528b62280f72ad700d3fc">&#9670;&nbsp;</a></span>Create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>* gtirb::CodeBlock::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an unitialized <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html" title="The context under which GTIRB operations occur.">Context</a> in which this <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a> will be held. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a>. </dd></dl>

</div>
</div>
<a id="a718bb0acbd3e2dcfc1ea0dc8068ebf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718bb0acbd3e2dcfc1ea0dc8068ebf57">&#9670;&nbsp;</a></span>Create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>* gtirb::CodeBlock::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>DecodeMode</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html" title="The context under which GTIRB operations occur.">Context</a> in which this block will be held. </td></tr>
    <tr><td class="paramname">Size</td><td>The size of the block in bytes. </td></tr>
    <tr><td class="paramname">DecodeMode</td><td>The decode mode of the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a>. </dd></dl>

</div>
</div>
<a id="ae4b422fc7b8432677c0ba0fde33064f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b422fc7b8432677c0ba0fde33064f7">&#9670;&nbsp;</a></span>getAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classgtirb_1_1_addr.html">Addr</a>&gt; gtirb::CodeBlock::getAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address of this block, if present. See <a class="el" href="classgtirb_1_1_byte_interval.html#aaf13ececea7d2b943402feeb4f1aae35">ByteInterval::getAddress</a> for details on why this address may not be present. </p>

</div>
</div>
<a id="adcb3d8fccb8ce8b9cfc1678ebcad05b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb3d8fccb8ce8b9cfc1678ebcad05b0">&#9670;&nbsp;</a></span>getByteInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>* gtirb::CodeBlock::getByteInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to. </p>

</div>
</div>
<a id="a724aec9ad4956998877668c7e0cd3885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724aec9ad4956998877668c7e0cd3885">&#9670;&nbsp;</a></span>getByteInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>* gtirb::CodeBlock::getByteInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to. </p>

</div>
</div>
<a id="a143f2f0de1998148d2cf5c5bac34d508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143f2f0de1998148d2cf5c5bac34d508">&#9670;&nbsp;</a></span>getDecodeMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gtirb::CodeBlock::getDecodeMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the decode mode from a <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </p>
<p>This field is used in some ISAs where it is used to differentiate between sub-ISAs; ARM and Thumb, for example.</p>
<dl class="section return"><dt>Returns</dt><dd>The decode mode. </dd></dl>

</div>
</div>
<a id="a9c7b31450f8be4854d4676222593c176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7b31450f8be4854d4676222593c176">&#9670;&nbsp;</a></span>getOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gtirb::CodeBlock::getOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the offset from the beginning of the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to. </p>

</div>
</div>
<a id="a012484e3c79c8a8758533f92506058b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012484e3c79c8a8758533f92506058b4">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gtirb::CodeBlock::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size from a <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes.</dd></dl>
<p>Use with <a class="el" href="classgtirb_1_1_code_block.html#ae4b422fc7b8432677c0ba0fde33064f7" title="Get the address of this block, if present. See ByteInterval::getAddress for details on why this addre...">CodeBlock::getAddress()</a> to obtain arguments to pass to ByteMap::data() for an iterator over the contents of a <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </p>

</div>
</div>
<a id="a675d80fc346a55c24e54d0c1a7be4e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675d80fc346a55c24e54d0c1a7be4e24">&#9670;&nbsp;</a></span>rawBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* gtirb::CodeBlock::rawBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the raw data underlying this block's byte vector. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<p>Much like std::vector::data, this function is low-level and potentially unsafe. This pointer refers to valid memory only where an iterator would be valid to point to. Modifying the size of the byte vector may invalidate this pointer. Any endian conversions will not be performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type.</td></tr>
  </table>
  </dd>
</dl>
<p>\retrurn A pointer to raw data. </p>

</div>
</div>
<a id="aae4494bd1af45efde9831f9e8e095030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4494bd1af45efde9831f9e8e095030">&#9670;&nbsp;</a></span>rawBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* gtirb::CodeBlock::rawBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the raw data underlying this block's byte vector. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<p>Much like std::vector::data, this function is low-level and potentially unsafe. This pointer refers to valid memory only where an iterator would be valid to point to. Modifying the size of the byte vector may invalidate this pointer. Any endian conversions will not be performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type.</td></tr>
  </table>
  </dd>
</dl>
<p>\retrurn A pointer to raw data. </p>

</div>
</div>
<a id="a54a281e633e076794f0cca587a99b5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a281e633e076794f0cca587a99b5f0">&#9670;&nbsp;</a></span>setDecodeMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtirb::CodeBlock::setDecodeMode </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>DM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the decode mode of this block. </p>
<p>This field is used in some ISAs where it is used to differentiate between sub-ISAs; ARM and Thumb, for example. </p>

</div>
</div>
<a id="a18e4316eb57d451ee5028a6c8dbdd286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e4316eb57d451ee5028a6c8dbdd286">&#9670;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtirb::CodeBlock::setSize </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of this block. </p>
<p>Note that this does not automatically update any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>'s size, bytes, or symbolic expressions. This simply changes the extents of a block in its <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2ed0265c4b443cda27a241352629170f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed0265c4b443cda27a241352629170f">&#9670;&nbsp;</a></span>ByteInterval</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac26c806e60ca4a0547680edb68f6e39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26c806e60ca4a0547680edb68f6e39b">&#9670;&nbsp;</a></span>Context</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgtirb_1_1_context.html">Context</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca7995861301f2eefb390acea47c34a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7995861301f2eefb390acea47c34a9">&#9670;&nbsp;</a></span>SerializationTestHarness</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SerializationTestHarness</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_code_block_8hpp_source.html">CodeBlock.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
