<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GTIRB: gtirb::ByteInterval Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GTIRB
   &#160;<span id="projectnumber">v1.10.4</span>
   </div>
   <div id="projectbrief">GrammaTech Intermediate Representation for Binaries: C++ API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegtirb.html">gtirb</a></li><li class="navelem"><a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgtirb_1_1_byte_interval-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gtirb::ByteInterval Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A contiguous region of bytes in a binary.  
 <a href="classgtirb_1_1_byte_interval.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_byte_interval_8hpp_source.html">ByteInterval.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for gtirb::ByteInterval:</div>
<div class="dyncontent">
<div class="center"><img src="classgtirb_1_1_byte_interval__inherit__graph.png" border="0" usemap="#agtirb_1_1_byte_interval_inherit__map" alt="Inheritance graph"/></div>
<map name="agtirb_1_1_byte_interval_inherit__map" id="agtirb_1_1_byte_interval_inherit__map">
<area shape="rect" title="A contiguous region of bytes in a binary." alt="" coords="5,80,131,107"/>
<area shape="rect" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy." alt="" coords="25,5,111,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for gtirb::ByteInterval:</div>
<div class="dyncontent">
<div class="center"><img src="classgtirb_1_1_byte_interval__coll__graph.png" border="0" usemap="#agtirb_1_1_byte_interval_coll__map" alt="Collaboration graph"/></div>
<map name="agtirb_1_1_byte_interval_coll__map" id="agtirb_1_1_byte_interval_coll__map">
<area shape="rect" title="A contiguous region of bytes in a binary." alt="" coords="5,80,131,107"/>
<area shape="rect" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy." alt="" coords="25,5,111,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a906497ecbe80ec11c48115066609face"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a906497ecbe80ec11c48115066609face">block_iterator</a> = boost::transform_iterator&lt; BlockToNode&lt; <a class="el" href="classgtirb_1_1_node.html">Node</a> &gt;, BlockSet::index&lt; by_offset &gt;::type::iterator &gt;</td></tr>
<tr class="memdesc:a906497ecbe80ec11c48115066609face"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over Block objects.  <a href="classgtirb_1_1_byte_interval.html#a906497ecbe80ec11c48115066609face">More...</a><br /></td></tr>
<tr class="separator:a906497ecbe80ec11c48115066609face"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b9128195d9da23d68d66669049bdf1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#a906497ecbe80ec11c48115066609face">block_iterator</a> &gt;</td></tr>
<tr class="memdesc:a47b9128195d9da23d68d66669049bdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of Block objects.  <a href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">More...</a><br /></td></tr>
<tr class="separator:a47b9128195d9da23d68d66669049bdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b01abb4d4050e12ac762d248d1f5a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a99b01abb4d4050e12ac762d248d1f5a1">block_subrange</a> = boost::iterator_range&lt; boost::transform_iterator&lt; BlockToNode&lt; <a class="el" href="classgtirb_1_1_node.html">Node</a> &gt;, BlockIntMap::codomain_type::iterator &gt; &gt;</td></tr>
<tr class="memdesc:a99b01abb4d4050e12ac762d248d1f5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-range of blocks overlapping an address or range of addreses.  <a href="classgtirb_1_1_byte_interval.html#a99b01abb4d4050e12ac762d248d1f5a1">More...</a><br /></td></tr>
<tr class="separator:a99b01abb4d4050e12ac762d248d1f5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e0a4733ed217016369e4a56188947f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21e0a4733ed217016369e4a56188947f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a> = BytesBaseIterator&lt; <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, T &gt;</td></tr>
<tr class="memdesc:a21e0a4733ed217016369e4a56188947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over bytes.  <a href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">More...</a><br /></td></tr>
<tr class="separator:a21e0a4733ed217016369e4a56188947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336fa6e85522d894640e366e687ac899"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a336fa6e85522d894640e366e687ac899"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">bytes_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a336fa6e85522d894640e366e687ac899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range over bytes.  <a href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">More...</a><br /></td></tr>
<tr class="separator:a336fa6e85522d894640e366e687ac899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5616996099d2349bf3808b69f35e0267"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a5616996099d2349bf3808b69f35e0267">code_block_iterator</a> = boost::transform_iterator&lt; BlockToNode&lt; <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> &gt;, boost::filter_iterator&lt; BlockKindEquals&lt; Node::Kind::CodeBlock &gt;, BlockSet::index&lt; by_offset &gt;::type::iterator &gt; &gt;</td></tr>
<tr class="memdesc:a5616996099d2349bf3808b69f35e0267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects.  <a href="classgtirb_1_1_byte_interval.html#a5616996099d2349bf3808b69f35e0267">More...</a><br /></td></tr>
<tr class="separator:a5616996099d2349bf3808b69f35e0267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade3e2c337788ff115b5547c795ea9c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#a5616996099d2349bf3808b69f35e0267">code_block_iterator</a> &gt;</td></tr>
<tr class="memdesc:aade3e2c337788ff115b5547c795ea9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects.  <a href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">More...</a><br /></td></tr>
<tr class="separator:aade3e2c337788ff115b5547c795ea9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e2f48c16615b2f9c2c84daaa3c3cda"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a81e2f48c16615b2f9c2c84daaa3c3cda">code_block_subrange</a> = boost::iterator_range&lt; boost::transform_iterator&lt; BlockToNode&lt; <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> &gt;, boost::filter_iterator&lt; BlockKindEquals&lt; Node::Kind::CodeBlock &gt;, boost::indirect_iterator&lt; BlockIntMap::codomain_type::iterator &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:a81e2f48c16615b2f9c2c84daaa3c3cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-range of code blocks overlapping an address or range of addreses.  <a href="classgtirb_1_1_byte_interval.html#a81e2f48c16615b2f9c2c84daaa3c3cda">More...</a><br /></td></tr>
<tr class="separator:a81e2f48c16615b2f9c2c84daaa3c3cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7a62cf27007ec7f00120e86d11273e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aeb7a62cf27007ec7f00120e86d11273e">const_block_iterator</a> = boost::transform_iterator&lt; BlockToNode&lt; const <a class="el" href="classgtirb_1_1_node.html">Node</a> &gt;, BlockSet::index&lt; by_offset &gt;::type::const_iterator &gt;</td></tr>
<tr class="memdesc:aeb7a62cf27007ec7f00120e86d11273e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over Block objects.  <a href="classgtirb_1_1_byte_interval.html#aeb7a62cf27007ec7f00120e86d11273e">More...</a><br /></td></tr>
<tr class="separator:aeb7a62cf27007ec7f00120e86d11273e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb2273d4049f8e88ee1901e80e872f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#aeb7a62cf27007ec7f00120e86d11273e">const_block_iterator</a> &gt;</td></tr>
<tr class="memdesc:aecb2273d4049f8e88ee1901e80e872f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const range of Block objects.  <a href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">More...</a><br /></td></tr>
<tr class="separator:aecb2273d4049f8e88ee1901e80e872f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce195b80ff3bccce7f426c985a49014"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a0ce195b80ff3bccce7f426c985a49014">const_block_subrange</a> = boost::iterator_range&lt; boost::transform_iterator&lt; BlockToNode&lt; const <a class="el" href="classgtirb_1_1_node.html">Node</a> &gt;, BlockIntMap::codomain_type::const_iterator &gt; &gt;</td></tr>
<tr class="memdesc:a0ce195b80ff3bccce7f426c985a49014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const sub-range of blocks overlapping an address or range of addreses.  <a href="classgtirb_1_1_byte_interval.html#a0ce195b80ff3bccce7f426c985a49014">More...</a><br /></td></tr>
<tr class="separator:a0ce195b80ff3bccce7f426c985a49014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56b387cd5cdb902b2ecb0bc1a85103f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac56b387cd5cdb902b2ecb0bc1a85103f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a> = BytesBaseIterator&lt; const <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, T &gt;</td></tr>
<tr class="memdesc:ac56b387cd5cdb902b2ecb0bc1a85103f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over bytes.  <a href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">More...</a><br /></td></tr>
<tr class="separator:ac56b387cd5cdb902b2ecb0bc1a85103f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c13a9122d82ff91df93cefaff12e47"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2c13a9122d82ff91df93cefaff12e47"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">const_bytes_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:aa2c13a9122d82ff91df93cefaff12e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const range over bytes.  <a href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">More...</a><br /></td></tr>
<tr class="separator:aa2c13a9122d82ff91df93cefaff12e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e6b824d4be6f520ad00d485ea1540c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a41e6b824d4be6f520ad00d485ea1540c">const_code_block_iterator</a> = boost::transform_iterator&lt; BlockToNode&lt; const <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> &gt;, boost::filter_iterator&lt; BlockKindEquals&lt; Node::Kind::CodeBlock &gt;, BlockSet::index&lt; by_offset &gt;::type::const_iterator &gt; &gt;</td></tr>
<tr class="memdesc:a41e6b824d4be6f520ad00d485ea1540c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects.  <a href="classgtirb_1_1_byte_interval.html#a41e6b824d4be6f520ad00d485ea1540c">More...</a><br /></td></tr>
<tr class="separator:a41e6b824d4be6f520ad00d485ea1540c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cf4ad54f003fc78102cca1ddb85b18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#a41e6b824d4be6f520ad00d485ea1540c">const_code_block_iterator</a> &gt;</td></tr>
<tr class="memdesc:a66cf4ad54f003fc78102cca1ddb85b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects.  <a href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">More...</a><br /></td></tr>
<tr class="separator:a66cf4ad54f003fc78102cca1ddb85b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a2c7a6e0289bb8c81506131f4c2dc6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a65a2c7a6e0289bb8c81506131f4c2dc6">const_code_block_subrange</a> = boost::iterator_range&lt; boost::transform_iterator&lt; BlockToNode&lt; const <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> &gt;, boost::filter_iterator&lt; BlockKindEquals&lt; Node::Kind::CodeBlock &gt;, boost::indirect_iterator&lt; BlockIntMap::codomain_type::const_iterator &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:a65a2c7a6e0289bb8c81506131f4c2dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const sub-range of code blocks overlapping an address or range of addreses.  <a href="classgtirb_1_1_byte_interval.html#a65a2c7a6e0289bb8c81506131f4c2dc6">More...</a><br /></td></tr>
<tr class="separator:a65a2c7a6e0289bb8c81506131f4c2dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6ec5081f685d60287e0eb89cf24818"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aba6ec5081f685d60287e0eb89cf24818">const_data_block_iterator</a> = boost::transform_iterator&lt; BlockToNode&lt; const <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> &gt;, boost::filter_iterator&lt; BlockKindEquals&lt; Node::Kind::DataBlock &gt;, BlockSet::index&lt; by_offset &gt;::type::const_iterator &gt; &gt;</td></tr>
<tr class="memdesc:aba6ec5081f685d60287e0eb89cf24818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects.  <a href="classgtirb_1_1_byte_interval.html#aba6ec5081f685d60287e0eb89cf24818">More...</a><br /></td></tr>
<tr class="separator:aba6ec5081f685d60287e0eb89cf24818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6246849157b58c6860bf2aeb6702ac02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#aba6ec5081f685d60287e0eb89cf24818">const_data_block_iterator</a> &gt;</td></tr>
<tr class="memdesc:a6246849157b58c6860bf2aeb6702ac02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects.  <a href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">More...</a><br /></td></tr>
<tr class="separator:a6246849157b58c6860bf2aeb6702ac02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07919c9f159f58b568f68bc59b61d43f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a07919c9f159f58b568f68bc59b61d43f">const_data_block_subrange</a> = boost::iterator_range&lt; boost::transform_iterator&lt; BlockToNode&lt; const <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> &gt;, boost::filter_iterator&lt; BlockKindEquals&lt; Node::Kind::DataBlock &gt;, boost::indirect_iterator&lt; BlockIntMap::codomain_type::const_iterator &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:a07919c9f159f58b568f68bc59b61d43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const sub-range of data blocks overlapping an address or range of addreses.  <a href="classgtirb_1_1_byte_interval.html#a07919c9f159f58b568f68bc59b61d43f">More...</a><br /></td></tr>
<tr class="separator:a07919c9f159f58b568f68bc59b61d43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b707f7e9e50062a468b820d7e79f87"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ad8b707f7e9e50062a468b820d7e79f87">const_symbolic_expression_iterator</a> = boost::transform_iterator&lt; SymExprPairToElement&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#aa1bbd096535989c0dca8b61951bae925">ConstSymbolicExpressionElement</a> &gt;, SymbolicExpressionMap::const_iterator &gt;</td></tr>
<tr class="memdesc:ad8b707f7e9e50062a468b820d7e79f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> objects.  <a href="classgtirb_1_1_byte_interval.html#ad8b707f7e9e50062a468b820d7e79f87">More...</a><br /></td></tr>
<tr class="separator:ad8b707f7e9e50062a468b820d7e79f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d187d303d730cbb3fda3621293b9c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#ad8b707f7e9e50062a468b820d7e79f87">const_symbolic_expression_iterator</a> &gt;</td></tr>
<tr class="memdesc:a44d187d303d730cbb3fda3621293b9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const range of <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> objects.  <a href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">More...</a><br /></td></tr>
<tr class="separator:a44d187d303d730cbb3fda3621293b9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bbd096535989c0dca8b61951bae925"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aa1bbd096535989c0dca8b61951bae925">ConstSymbolicExpressionElement</a> = SymbolicExpressionElementBase&lt; const <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> &gt;</td></tr>
<tr class="memdesc:aa1bbd096535989c0dca8b61951bae925"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbolic expression paired with the information needed to look up or alter the symbolic expression after the fact.  <a href="classgtirb_1_1_byte_interval.html#aa1bbd096535989c0dca8b61951bae925">More...</a><br /></td></tr>
<tr class="separator:aa1bbd096535989c0dca8b61951bae925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba13200137a60aa6d6bfd93eaa6dd89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#acba13200137a60aa6d6bfd93eaa6dd89">data_block_iterator</a> = boost::transform_iterator&lt; BlockToNode&lt; <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> &gt;, boost::filter_iterator&lt; BlockKindEquals&lt; Node::Kind::DataBlock &gt;, BlockSet::index&lt; by_offset &gt;::type::iterator &gt; &gt;</td></tr>
<tr class="memdesc:acba13200137a60aa6d6bfd93eaa6dd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects.  <a href="classgtirb_1_1_byte_interval.html#acba13200137a60aa6d6bfd93eaa6dd89">More...</a><br /></td></tr>
<tr class="separator:acba13200137a60aa6d6bfd93eaa6dd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fb519c7a9522d6e0f581dd5483dfbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#acba13200137a60aa6d6bfd93eaa6dd89">data_block_iterator</a> &gt;</td></tr>
<tr class="memdesc:a02fb519c7a9522d6e0f581dd5483dfbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects.  <a href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">More...</a><br /></td></tr>
<tr class="separator:a02fb519c7a9522d6e0f581dd5483dfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306f0089a518e8c7f70125f8ffd5bf8e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a306f0089a518e8c7f70125f8ffd5bf8e">data_block_subrange</a> = boost::iterator_range&lt; boost::transform_iterator&lt; BlockToNode&lt; <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> &gt;, boost::filter_iterator&lt; BlockKindEquals&lt; Node::Kind::DataBlock &gt;, boost::indirect_iterator&lt; BlockIntMap::codomain_type::iterator &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:a306f0089a518e8c7f70125f8ffd5bf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-range of data blocks overlapping an address or range of addreses.  <a href="classgtirb_1_1_byte_interval.html#a306f0089a518e8c7f70125f8ffd5bf8e">More...</a><br /></td></tr>
<tr class="separator:a306f0089a518e8c7f70125f8ffd5bf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e013b5817c7046b1791904debac22e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ae3e013b5817c7046b1791904debac22e">symbolic_expression_iterator</a> = boost::transform_iterator&lt; SymExprPairToElement&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> &gt;, SymbolicExpressionMap::iterator &gt;</td></tr>
<tr class="memdesc:ae3e013b5817c7046b1791904debac22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> objects.  <a href="classgtirb_1_1_byte_interval.html#ae3e013b5817c7046b1791904debac22e">More...</a><br /></td></tr>
<tr class="separator:ae3e013b5817c7046b1791904debac22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd12ca596011ad35839c267401d4e588"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a> = boost::iterator_range&lt; <a class="el" href="classgtirb_1_1_byte_interval.html#ae3e013b5817c7046b1791904debac22e">symbolic_expression_iterator</a> &gt;</td></tr>
<tr class="memdesc:afd12ca596011ad35839c267401d4e588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> objects.  <a href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">More...</a><br /></td></tr>
<tr class="separator:afd12ca596011ad35839c267401d4e588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e05737b52c2128bd81c4559f9534df9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> = SymbolicExpressionElementBase&lt; <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> &gt;</td></tr>
<tr class="memdesc:a3e05737b52c2128bd81c4559f9534df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbolic expression paired with the information needed to look up or alter the symbolic expression after the fact.  <a href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">More...</a><br /></td></tr>
<tr class="separator:a3e05737b52c2128bd81c4559f9534df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad239f11f34051bd7c536c3c903738641"><td class="memTemplParams" colspan="2">template&lt;typename BlockType , typename... Args&gt; </td></tr>
<tr class="memitem:ad239f11f34051bd7c536c3c903738641"><td class="memTemplItemLeft" align="right" valign="top">BlockType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ad239f11f34051bd7c536c3c903738641">addBlock</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, uint64_t O, Args &amp;&amp;... A)</td></tr>
<tr class="memdesc:ad239f11f34051bd7c536c3c903738641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Block of the given type at a given offset.  <a href="classgtirb_1_1_byte_interval.html#ad239f11f34051bd7c536c3c903738641">More...</a><br /></td></tr>
<tr class="separator:ad239f11f34051bd7c536c3c903738641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f01446fb6e3fcdea2a4f4c86e915bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegtirb.html#ad7db2026ea49abab0562fd0cf344a00b">ChangeStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aa8f01446fb6e3fcdea2a4f4c86e915bf">addBlock</a> (uint64_t Off, <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> *N)</td></tr>
<tr class="memdesc:aa8f01446fb6e3fcdea2a4f4c86e915bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a> to be a part of this interval.  <a href="classgtirb_1_1_byte_interval.html#aa8f01446fb6e3fcdea2a4f4c86e915bf">More...</a><br /></td></tr>
<tr class="separator:aa8f01446fb6e3fcdea2a4f4c86e915bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019f94b6345c87726872ad9bd5eb664d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegtirb.html#ad7db2026ea49abab0562fd0cf344a00b">ChangeStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a019f94b6345c87726872ad9bd5eb664d">addBlock</a> (uint64_t Off, <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> *N)</td></tr>
<tr class="memdesc:a019f94b6345c87726872ad9bd5eb664d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a> to be a part of this interval.  <a href="classgtirb_1_1_byte_interval.html#a019f94b6345c87726872ad9bd5eb664d">More...</a><br /></td></tr>
<tr class="separator:a019f94b6345c87726872ad9bd5eb664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d01fa068e0484d58f374d2c128d0f2"><td class="memTemplParams" colspan="2">template&lt;class ExprType , class... Args&gt; </td></tr>
<tr class="memitem:a75d01fa068e0484d58f374d2c128d0f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a75d01fa068e0484d58f374d2c128d0f2">addSymbolicExpression</a> (uint64_t Off, Args... A)</td></tr>
<tr class="memdesc:a75d01fa068e0484d58f374d2c128d0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> to this interval.  <a href="classgtirb_1_1_byte_interval.html#a75d01fa068e0484d58f374d2c128d0f2">More...</a><br /></td></tr>
<tr class="separator:a75d01fa068e0484d58f374d2c128d0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e4791188ab46a92d1242f337eba656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a74e4791188ab46a92d1242f337eba656">addSymbolicExpression</a> (uint64_t Off, const <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> &amp;SymExpr)</td></tr>
<tr class="memdesc:a74e4791188ab46a92d1242f337eba656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> to this interval.  <a href="classgtirb_1_1_byte_interval.html#a74e4791188ab46a92d1242f337eba656">More...</a><br /></td></tr>
<tr class="separator:a74e4791188ab46a92d1242f337eba656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b3279ea359b70e1bd83e3936e41e65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a94b3279ea359b70e1bd83e3936e41e65">blocks</a> ()</td></tr>
<tr class="memdesc:a94b3279ea359b70e1bd83e3936e41e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range of the Block objects in this interval.  <a href="classgtirb_1_1_byte_interval.html#a94b3279ea359b70e1bd83e3936e41e65">More...</a><br /></td></tr>
<tr class="separator:a94b3279ea359b70e1bd83e3936e41e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc87b6ac73b67d6cc19936e24b991ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a1fc87b6ac73b67d6cc19936e24b991ef">blocks</a> () const</td></tr>
<tr class="memdesc:a1fc87b6ac73b67d6cc19936e24b991ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const range of the Block objects in this interval.  <a href="classgtirb_1_1_byte_interval.html#a1fc87b6ac73b67d6cc19936e24b991ef">More...</a><br /></td></tr>
<tr class="separator:a1fc87b6ac73b67d6cc19936e24b991ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e8ea8f850238b35f0f2c919537c9f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a906497ecbe80ec11c48115066609face">block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a80e8ea8f850238b35f0f2c919537c9f8">blocks_begin</a> ()</td></tr>
<tr class="memdesc:a80e8ea8f850238b35f0f2c919537c9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first Block.  <a href="classgtirb_1_1_byte_interval.html#a80e8ea8f850238b35f0f2c919537c9f8">More...</a><br /></td></tr>
<tr class="separator:a80e8ea8f850238b35f0f2c919537c9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ffba5b7f527ad10399e46b26edbc0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aeb7a62cf27007ec7f00120e86d11273e">const_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#af1ffba5b7f527ad10399e46b26edbc0a">blocks_begin</a> () const</td></tr>
<tr class="memdesc:af1ffba5b7f527ad10399e46b26edbc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the first Block.  <a href="classgtirb_1_1_byte_interval.html#af1ffba5b7f527ad10399e46b26edbc0a">More...</a><br /></td></tr>
<tr class="separator:af1ffba5b7f527ad10399e46b26edbc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64ba0ca13df34c709da7ffe9c6f88ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a906497ecbe80ec11c48115066609face">block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aa64ba0ca13df34c709da7ffe9c6f88ab">blocks_end</a> ()</td></tr>
<tr class="memdesc:aa64ba0ca13df34c709da7ffe9c6f88ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the element following the last Block.  <a href="classgtirb_1_1_byte_interval.html#aa64ba0ca13df34c709da7ffe9c6f88ab">More...</a><br /></td></tr>
<tr class="separator:aa64ba0ca13df34c709da7ffe9c6f88ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d2fafc0d043da8b7af8afd14c2c546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aeb7a62cf27007ec7f00120e86d11273e">const_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aa2d2fafc0d043da8b7af8afd14c2c546">blocks_end</a> () const</td></tr>
<tr class="memdesc:aa2d2fafc0d043da8b7af8afd14c2c546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the element following the last Block.  <a href="classgtirb_1_1_byte_interval.html#aa2d2fafc0d043da8b7af8afd14c2c546">More...</a><br /></td></tr>
<tr class="separator:aa2d2fafc0d043da8b7af8afd14c2c546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307c16d10cb2fa7225c2673926c2d8d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a307c16d10cb2fa7225c2673926c2d8d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a307c16d10cb2fa7225c2673926c2d8d5">bytes</a> ()</td></tr>
<tr class="memdesc:a307c16d10cb2fa7225c2673926c2d8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of data in this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a307c16d10cb2fa7225c2673926c2d8d5">More...</a><br /></td></tr>
<tr class="separator:a307c16d10cb2fa7225c2673926c2d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303ad2e729e34747f4c5ce3d36c54a50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a303ad2e729e34747f4c5ce3d36c54a50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">const_bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a303ad2e729e34747f4c5ce3d36c54a50">bytes</a> () const</td></tr>
<tr class="memdesc:a303ad2e729e34747f4c5ce3d36c54a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of data in this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a303ad2e729e34747f4c5ce3d36c54a50">More...</a><br /></td></tr>
<tr class="separator:a303ad2e729e34747f4c5ce3d36c54a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9787dd32694232dd6f6803c07da6f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a9787dd32694232dd6f6803c07da6f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a6a9787dd32694232dd6f6803c07da6f0">bytes</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:a6a9787dd32694232dd6f6803c07da6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of data in this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a6a9787dd32694232dd6f6803c07da6f0">More...</a><br /></td></tr>
<tr class="separator:a6a9787dd32694232dd6f6803c07da6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4978ed9a080ed359d2e59fc5cc3eb4e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4978ed9a080ed359d2e59fc5cc3eb4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">const_bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ac4978ed9a080ed359d2e59fc5cc3eb4e">bytes</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native) const</td></tr>
<tr class="memdesc:ac4978ed9a080ed359d2e59fc5cc3eb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of data in this byte vector.  <a href="classgtirb_1_1_byte_interval.html#ac4978ed9a080ed359d2e59fc5cc3eb4e">More...</a><br /></td></tr>
<tr class="separator:ac4978ed9a080ed359d2e59fc5cc3eb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f99034eff9124ad9227658313e0adf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86f99034eff9124ad9227658313e0adf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a86f99034eff9124ad9227658313e0adf">bytes_begin</a> ()</td></tr>
<tr class="memdesc:a86f99034eff9124ad9227658313e0adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning of this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a86f99034eff9124ad9227658313e0adf">More...</a><br /></td></tr>
<tr class="separator:a86f99034eff9124ad9227658313e0adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ed5f5390c78d33be9ab94e0423f9f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86ed5f5390c78d33be9ab94e0423f9f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a86ed5f5390c78d33be9ab94e0423f9f3">bytes_begin</a> () const</td></tr>
<tr class="memdesc:a86ed5f5390c78d33be9ab94e0423f9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning of this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a86ed5f5390c78d33be9ab94e0423f9f3">More...</a><br /></td></tr>
<tr class="separator:a86ed5f5390c78d33be9ab94e0423f9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ff5e74bd9a5908e4c383dac046cd56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68ff5e74bd9a5908e4c383dac046cd56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a68ff5e74bd9a5908e4c383dac046cd56">bytes_begin</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:a68ff5e74bd9a5908e4c383dac046cd56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning of this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a68ff5e74bd9a5908e4c383dac046cd56">More...</a><br /></td></tr>
<tr class="separator:a68ff5e74bd9a5908e4c383dac046cd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c1b2f7f97048547d5daabdcd1ef551"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7c1b2f7f97048547d5daabdcd1ef551"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ae7c1b2f7f97048547d5daabdcd1ef551">bytes_begin</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native) const</td></tr>
<tr class="memdesc:ae7c1b2f7f97048547d5daabdcd1ef551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning of this byte vector.  <a href="classgtirb_1_1_byte_interval.html#ae7c1b2f7f97048547d5daabdcd1ef551">More...</a><br /></td></tr>
<tr class="separator:ae7c1b2f7f97048547d5daabdcd1ef551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bf693f878f160fb775043b57fb6c9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3bf693f878f160fb775043b57fb6c9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ab3bf693f878f160fb775043b57fb6c9c">bytes_end</a> ()</td></tr>
<tr class="memdesc:ab3bf693f878f160fb775043b57fb6c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the end of this byte vector.  <a href="classgtirb_1_1_byte_interval.html#ab3bf693f878f160fb775043b57fb6c9c">More...</a><br /></td></tr>
<tr class="separator:ab3bf693f878f160fb775043b57fb6c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626a0758bc7fb99836eefcdc26e299c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a626a0758bc7fb99836eefcdc26e299c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a626a0758bc7fb99836eefcdc26e299c8">bytes_end</a> () const</td></tr>
<tr class="memdesc:a626a0758bc7fb99836eefcdc26e299c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the end of this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a626a0758bc7fb99836eefcdc26e299c8">More...</a><br /></td></tr>
<tr class="separator:a626a0758bc7fb99836eefcdc26e299c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbfbe9829a17f14e54410ac613230e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfbfbe9829a17f14e54410ac613230e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#abfbfbe9829a17f14e54410ac613230e3">bytes_end</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:abfbfbe9829a17f14e54410ac613230e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the end of this byte vector.  <a href="classgtirb_1_1_byte_interval.html#abfbfbe9829a17f14e54410ac613230e3">More...</a><br /></td></tr>
<tr class="separator:abfbfbe9829a17f14e54410ac613230e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71737db3829444e128b677da15b8774"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad71737db3829444e128b677da15b8774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ad71737db3829444e128b677da15b8774">bytes_end</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native) const</td></tr>
<tr class="memdesc:ad71737db3829444e128b677da15b8774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the end of this byte vector.  <a href="classgtirb_1_1_byte_interval.html#ad71737db3829444e128b677da15b8774">More...</a><br /></td></tr>
<tr class="separator:ad71737db3829444e128b677da15b8774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8ef982b7b2b4862e3fe569de719832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aec8ef982b7b2b4862e3fe569de719832">code_blocks</a> ()</td></tr>
<tr class="memdesc:aec8ef982b7b2b4862e3fe569de719832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range of the <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects in this interval.  <a href="classgtirb_1_1_byte_interval.html#aec8ef982b7b2b4862e3fe569de719832">More...</a><br /></td></tr>
<tr class="separator:aec8ef982b7b2b4862e3fe569de719832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1770e97b003da509e318ee34f728fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aa1770e97b003da509e318ee34f728fe9">code_blocks</a> () const</td></tr>
<tr class="memdesc:aa1770e97b003da509e318ee34f728fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const range of the <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects in this interval.  <a href="classgtirb_1_1_byte_interval.html#aa1770e97b003da509e318ee34f728fe9">More...</a><br /></td></tr>
<tr class="separator:aa1770e97b003da509e318ee34f728fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43599abd3770fd1a9ed358c46cefb93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a5616996099d2349bf3808b69f35e0267">code_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ab43599abd3770fd1a9ed358c46cefb93">code_blocks_begin</a> ()</td></tr>
<tr class="memdesc:ab43599abd3770fd1a9ed358c46cefb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>.  <a href="classgtirb_1_1_byte_interval.html#ab43599abd3770fd1a9ed358c46cefb93">More...</a><br /></td></tr>
<tr class="separator:ab43599abd3770fd1a9ed358c46cefb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68a85fda320a4605d21af05cef200c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a41e6b824d4be6f520ad00d485ea1540c">const_code_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#af68a85fda320a4605d21af05cef200c7">code_blocks_begin</a> () const</td></tr>
<tr class="memdesc:af68a85fda320a4605d21af05cef200c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the first <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>.  <a href="classgtirb_1_1_byte_interval.html#af68a85fda320a4605d21af05cef200c7">More...</a><br /></td></tr>
<tr class="separator:af68a85fda320a4605d21af05cef200c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f35d331b2c4cd8873ee3eeaf2fb2d29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a5616996099d2349bf3808b69f35e0267">code_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a6f35d331b2c4cd8873ee3eeaf2fb2d29">code_blocks_end</a> ()</td></tr>
<tr class="memdesc:a6f35d331b2c4cd8873ee3eeaf2fb2d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the element following the last <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>.  <a href="classgtirb_1_1_byte_interval.html#a6f35d331b2c4cd8873ee3eeaf2fb2d29">More...</a><br /></td></tr>
<tr class="separator:a6f35d331b2c4cd8873ee3eeaf2fb2d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d7f6f0b9c401e3cce9f4857bd26c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a41e6b824d4be6f520ad00d485ea1540c">const_code_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a57d7f6f0b9c401e3cce9f4857bd26c3d">code_blocks_end</a> () const</td></tr>
<tr class="memdesc:a57d7f6f0b9c401e3cce9f4857bd26c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the element following the last <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>.  <a href="classgtirb_1_1_byte_interval.html#a57d7f6f0b9c401e3cce9f4857bd26c3d">More...</a><br /></td></tr>
<tr class="separator:a57d7f6f0b9c401e3cce9f4857bd26c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0e176eab6fee402d801559330d3df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a5e0e176eab6fee402d801559330d3df4">data_blocks</a> ()</td></tr>
<tr class="memdesc:a5e0e176eab6fee402d801559330d3df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range of the <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects in this interval.  <a href="classgtirb_1_1_byte_interval.html#a5e0e176eab6fee402d801559330d3df4">More...</a><br /></td></tr>
<tr class="separator:a5e0e176eab6fee402d801559330d3df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae099f21a30a0e41b749082675d5c55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a5ae099f21a30a0e41b749082675d5c55">data_blocks</a> () const</td></tr>
<tr class="memdesc:a5ae099f21a30a0e41b749082675d5c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const range of the <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects in this interval.  <a href="classgtirb_1_1_byte_interval.html#a5ae099f21a30a0e41b749082675d5c55">More...</a><br /></td></tr>
<tr class="separator:a5ae099f21a30a0e41b749082675d5c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd4f769883a604cc16958307ed17504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#acba13200137a60aa6d6bfd93eaa6dd89">data_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#addd4f769883a604cc16958307ed17504">data_blocks_begin</a> ()</td></tr>
<tr class="memdesc:addd4f769883a604cc16958307ed17504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>.  <a href="classgtirb_1_1_byte_interval.html#addd4f769883a604cc16958307ed17504">More...</a><br /></td></tr>
<tr class="separator:addd4f769883a604cc16958307ed17504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c0cfb7690cecaf8bb03c4e3ac0d6e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aba6ec5081f685d60287e0eb89cf24818">const_data_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a72c0cfb7690cecaf8bb03c4e3ac0d6e2">data_blocks_begin</a> () const</td></tr>
<tr class="memdesc:a72c0cfb7690cecaf8bb03c4e3ac0d6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the first <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>.  <a href="classgtirb_1_1_byte_interval.html#a72c0cfb7690cecaf8bb03c4e3ac0d6e2">More...</a><br /></td></tr>
<tr class="separator:a72c0cfb7690cecaf8bb03c4e3ac0d6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327f6b285d6d06940dcb7599279f346d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#acba13200137a60aa6d6bfd93eaa6dd89">data_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a327f6b285d6d06940dcb7599279f346d">data_blocks_end</a> ()</td></tr>
<tr class="memdesc:a327f6b285d6d06940dcb7599279f346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the element following the last <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>.  <a href="classgtirb_1_1_byte_interval.html#a327f6b285d6d06940dcb7599279f346d">More...</a><br /></td></tr>
<tr class="separator:a327f6b285d6d06940dcb7599279f346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3890092f828eee175043c62d4a41062e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aba6ec5081f685d60287e0eb89cf24818">const_data_block_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a3890092f828eee175043c62d4a41062e">data_blocks_end</a> () const</td></tr>
<tr class="memdesc:a3890092f828eee175043c62d4a41062e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the element following the last <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>.  <a href="classgtirb_1_1_byte_interval.html#a3890092f828eee175043c62d4a41062e">More...</a><br /></td></tr>
<tr class="separator:a3890092f828eee175043c62d4a41062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e87c4f2dc45ad83c3a035fb035585bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e87c4f2dc45ad83c3a035fb035585bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a0e87c4f2dc45ad83c3a035fb035585bb">eraseBytes</a> (const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt; Begin, const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt; End)</td></tr>
<tr class="memdesc:a0e87c4f2dc45ad83c3a035fb035585bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase data from this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a0e87c4f2dc45ad83c3a035fb035585bb">More...</a><br /></td></tr>
<tr class="separator:a0e87c4f2dc45ad83c3a035fb035585bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927a15b9dafee400206f1d01dee07a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a927a15b9dafee400206f1d01dee07a14">findBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A)</td></tr>
<tr class="memdesc:a927a15b9dafee400206f1d01dee07a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that start at an address.  <a href="classgtirb_1_1_byte_interval.html#a927a15b9dafee400206f1d01dee07a14">More...</a><br /></td></tr>
<tr class="separator:a927a15b9dafee400206f1d01dee07a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a27f065f253545f41f434e04ddb781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aa8a27f065f253545f41f434e04ddb781">findBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A) const</td></tr>
<tr class="memdesc:aa8a27f065f253545f41f434e04ddb781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that start at an address.  <a href="classgtirb_1_1_byte_interval.html#aa8a27f065f253545f41f434e04ddb781">More...</a><br /></td></tr>
<tr class="separator:aa8a27f065f253545f41f434e04ddb781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59878361318429a61e82bc5aa5e91b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a59878361318429a61e82bc5aa5e91b5f">findBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> Low, <a class="el" href="classgtirb_1_1_addr.html">Addr</a> High)</td></tr>
<tr class="memdesc:a59878361318429a61e82bc5aa5e91b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that start between a range of addresses.  <a href="classgtirb_1_1_byte_interval.html#a59878361318429a61e82bc5aa5e91b5f">More...</a><br /></td></tr>
<tr class="separator:a59878361318429a61e82bc5aa5e91b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec2f6e42a78aa0150c7cd74159116da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#acec2f6e42a78aa0150c7cd74159116da">findBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> Low, <a class="el" href="classgtirb_1_1_addr.html">Addr</a> High) const</td></tr>
<tr class="memdesc:acec2f6e42a78aa0150c7cd74159116da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that start between a range of addresses.  <a href="classgtirb_1_1_byte_interval.html#acec2f6e42a78aa0150c7cd74159116da">More...</a><br /></td></tr>
<tr class="separator:acec2f6e42a78aa0150c7cd74159116da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb451c5147d8d9132dce1b4f6578b188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#acb451c5147d8d9132dce1b4f6578b188">findBlocksAtOffset</a> (uint64_t Low, uint64_t High)</td></tr>
<tr class="memdesc:acb451c5147d8d9132dce1b4f6578b188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that start between a range of offsets.  <a href="classgtirb_1_1_byte_interval.html#acb451c5147d8d9132dce1b4f6578b188">More...</a><br /></td></tr>
<tr class="separator:acb451c5147d8d9132dce1b4f6578b188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf080a5162e79341ed299bade7081faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aaf080a5162e79341ed299bade7081faf">findBlocksAtOffset</a> (uint64_t Low, uint64_t High) const</td></tr>
<tr class="memdesc:aaf080a5162e79341ed299bade7081faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that start between a range of offsets.  <a href="classgtirb_1_1_byte_interval.html#aaf080a5162e79341ed299bade7081faf">More...</a><br /></td></tr>
<tr class="separator:aaf080a5162e79341ed299bade7081faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b9f490245e66078317ebd5ab6d3270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aa6b9f490245e66078317ebd5ab6d3270">findBlocksAtOffset</a> (uint64_t Off)</td></tr>
<tr class="memdesc:aa6b9f490245e66078317ebd5ab6d3270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that start at an offset.  <a href="classgtirb_1_1_byte_interval.html#aa6b9f490245e66078317ebd5ab6d3270">More...</a><br /></td></tr>
<tr class="separator:aa6b9f490245e66078317ebd5ab6d3270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed158ed4cead61409934c2a685cfad77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aed158ed4cead61409934c2a685cfad77">findBlocksAtOffset</a> (uint64_t Off) const</td></tr>
<tr class="memdesc:aed158ed4cead61409934c2a685cfad77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that start at an offset.  <a href="classgtirb_1_1_byte_interval.html#aed158ed4cead61409934c2a685cfad77">More...</a><br /></td></tr>
<tr class="separator:aed158ed4cead61409934c2a685cfad77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7227044a2a59cc232907d390a4db28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a99b01abb4d4050e12ac762d248d1f5a1">block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aab7227044a2a59cc232907d390a4db28">findBlocksOn</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A)</td></tr>
<tr class="memdesc:aab7227044a2a59cc232907d390a4db28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that have bytes that lie within the address specified.  <a href="classgtirb_1_1_byte_interval.html#aab7227044a2a59cc232907d390a4db28">More...</a><br /></td></tr>
<tr class="separator:aab7227044a2a59cc232907d390a4db28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35061b7611c01ccbaf45a1cb88867d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a0ce195b80ff3bccce7f426c985a49014">const_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a35061b7611c01ccbaf45a1cb88867d47">findBlocksOn</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A) const</td></tr>
<tr class="memdesc:a35061b7611c01ccbaf45a1cb88867d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that have bytes that lie within the address specified.  <a href="classgtirb_1_1_byte_interval.html#a35061b7611c01ccbaf45a1cb88867d47">More...</a><br /></td></tr>
<tr class="separator:a35061b7611c01ccbaf45a1cb88867d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3ba4b9b92fbcc2aa9185c8954c6c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a99b01abb4d4050e12ac762d248d1f5a1">block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aab3ba4b9b92fbcc2aa9185c8954c6c8f">findBlocksOnOffset</a> (uint64_t Off)</td></tr>
<tr class="memdesc:aab3ba4b9b92fbcc2aa9185c8954c6c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that have a byte at the specified offset.  <a href="classgtirb_1_1_byte_interval.html#aab3ba4b9b92fbcc2aa9185c8954c6c8f">More...</a><br /></td></tr>
<tr class="separator:aab3ba4b9b92fbcc2aa9185c8954c6c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281c4ea48641041871680d4f05ac852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a0ce195b80ff3bccce7f426c985a49014">const_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a2281c4ea48641041871680d4f05ac852">findBlocksOnOffset</a> (uint64_t Off) const</td></tr>
<tr class="memdesc:a2281c4ea48641041871680d4f05ac852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the blocks that have a byte at the specified offset.  <a href="classgtirb_1_1_byte_interval.html#a2281c4ea48641041871680d4f05ac852">More...</a><br /></td></tr>
<tr class="separator:a2281c4ea48641041871680d4f05ac852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2063ad11170d5a858694b3212e549ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ac2063ad11170d5a858694b3212e549ca">findCodeBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A)</td></tr>
<tr class="memdesc:ac2063ad11170d5a858694b3212e549ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that start at an address.  <a href="classgtirb_1_1_byte_interval.html#ac2063ad11170d5a858694b3212e549ca">More...</a><br /></td></tr>
<tr class="separator:ac2063ad11170d5a858694b3212e549ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd8a6071e823b89f00dfcf345468f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aefd8a6071e823b89f00dfcf345468f49">findCodeBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A) const</td></tr>
<tr class="memdesc:aefd8a6071e823b89f00dfcf345468f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that start at an address.  <a href="classgtirb_1_1_byte_interval.html#aefd8a6071e823b89f00dfcf345468f49">More...</a><br /></td></tr>
<tr class="separator:aefd8a6071e823b89f00dfcf345468f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0821f0d9cfbb0e5fbe778edf876749f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a0821f0d9cfbb0e5fbe778edf876749f6">findCodeBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> Low, <a class="el" href="classgtirb_1_1_addr.html">Addr</a> High)</td></tr>
<tr class="memdesc:a0821f0d9cfbb0e5fbe778edf876749f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that start between a range of addresses.  <a href="classgtirb_1_1_byte_interval.html#a0821f0d9cfbb0e5fbe778edf876749f6">More...</a><br /></td></tr>
<tr class="separator:a0821f0d9cfbb0e5fbe778edf876749f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a17470cf973d93c9b1d5ece82044c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ae8a17470cf973d93c9b1d5ece82044c5">findCodeBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> Low, <a class="el" href="classgtirb_1_1_addr.html">Addr</a> High) const</td></tr>
<tr class="memdesc:ae8a17470cf973d93c9b1d5ece82044c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that start between a range of addresses.  <a href="classgtirb_1_1_byte_interval.html#ae8a17470cf973d93c9b1d5ece82044c5">More...</a><br /></td></tr>
<tr class="separator:ae8a17470cf973d93c9b1d5ece82044c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a02ddd217ce6b6f2afc1d7dd9c0cfca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a4a02ddd217ce6b6f2afc1d7dd9c0cfca">findCodeBlocksAtOffset</a> (uint64_t Low, uint64_t High)</td></tr>
<tr class="memdesc:a4a02ddd217ce6b6f2afc1d7dd9c0cfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that start between a range of offsets.  <a href="classgtirb_1_1_byte_interval.html#a4a02ddd217ce6b6f2afc1d7dd9c0cfca">More...</a><br /></td></tr>
<tr class="separator:a4a02ddd217ce6b6f2afc1d7dd9c0cfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491a05604112f3662900f571f5af5823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a491a05604112f3662900f571f5af5823">findCodeBlocksAtOffset</a> (uint64_t Low, uint64_t High) const</td></tr>
<tr class="memdesc:a491a05604112f3662900f571f5af5823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that start between a range of offsets.  <a href="classgtirb_1_1_byte_interval.html#a491a05604112f3662900f571f5af5823">More...</a><br /></td></tr>
<tr class="separator:a491a05604112f3662900f571f5af5823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74604030ae0e750e3d7c3db567cd3c6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a74604030ae0e750e3d7c3db567cd3c6e">findCodeBlocksAtOffset</a> (uint64_t Off)</td></tr>
<tr class="memdesc:a74604030ae0e750e3d7c3db567cd3c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that start at an offset.  <a href="classgtirb_1_1_byte_interval.html#a74604030ae0e750e3d7c3db567cd3c6e">More...</a><br /></td></tr>
<tr class="separator:a74604030ae0e750e3d7c3db567cd3c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8eb24a288635ba4bb5ff132b00e4c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a9c8eb24a288635ba4bb5ff132b00e4c3">findCodeBlocksAtOffset</a> (uint64_t Off) const</td></tr>
<tr class="memdesc:a9c8eb24a288635ba4bb5ff132b00e4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that start at an offset.  <a href="classgtirb_1_1_byte_interval.html#a9c8eb24a288635ba4bb5ff132b00e4c3">More...</a><br /></td></tr>
<tr class="separator:a9c8eb24a288635ba4bb5ff132b00e4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889be6b137f1816d4736f0e88c23f0d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a81e2f48c16615b2f9c2c84daaa3c3cda">code_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a889be6b137f1816d4736f0e88c23f0d1">findCodeBlocksOn</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A)</td></tr>
<tr class="memdesc:a889be6b137f1816d4736f0e88c23f0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that have bytes that lie within the address specified.  <a href="classgtirb_1_1_byte_interval.html#a889be6b137f1816d4736f0e88c23f0d1">More...</a><br /></td></tr>
<tr class="separator:a889be6b137f1816d4736f0e88c23f0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479700aec6dd6e079d946676ce5abf1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a65a2c7a6e0289bb8c81506131f4c2dc6">const_code_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a479700aec6dd6e079d946676ce5abf1c">findCodeBlocksOn</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A) const</td></tr>
<tr class="memdesc:a479700aec6dd6e079d946676ce5abf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that have bytes that lie within the address specified.  <a href="classgtirb_1_1_byte_interval.html#a479700aec6dd6e079d946676ce5abf1c">More...</a><br /></td></tr>
<tr class="separator:a479700aec6dd6e079d946676ce5abf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07b10efdd925c4a6581c6e86c8b8215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a81e2f48c16615b2f9c2c84daaa3c3cda">code_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ac07b10efdd925c4a6581c6e86c8b8215">findCodeBlocksOnOffset</a> (uint64_t Off)</td></tr>
<tr class="memdesc:ac07b10efdd925c4a6581c6e86c8b8215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that have a byte at the specified offset.  <a href="classgtirb_1_1_byte_interval.html#ac07b10efdd925c4a6581c6e86c8b8215">More...</a><br /></td></tr>
<tr class="separator:ac07b10efdd925c4a6581c6e86c8b8215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06021a8ceb808795c299d6ba74b94735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a65a2c7a6e0289bb8c81506131f4c2dc6">const_code_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a06021a8ceb808795c299d6ba74b94735">findCodeBlocksOnOffset</a> (uint64_t Off) const</td></tr>
<tr class="memdesc:a06021a8ceb808795c299d6ba74b94735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the code blocks that have a byte at the specified offset.  <a href="classgtirb_1_1_byte_interval.html#a06021a8ceb808795c299d6ba74b94735">More...</a><br /></td></tr>
<tr class="separator:a06021a8ceb808795c299d6ba74b94735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dc5363c2d4ff56d14bfd48d751162f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a63dc5363c2d4ff56d14bfd48d751162f">findDataBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A)</td></tr>
<tr class="memdesc:a63dc5363c2d4ff56d14bfd48d751162f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that start at an address.  <a href="classgtirb_1_1_byte_interval.html#a63dc5363c2d4ff56d14bfd48d751162f">More...</a><br /></td></tr>
<tr class="separator:a63dc5363c2d4ff56d14bfd48d751162f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f0086f28d68784d3896eb1709489c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a92f0086f28d68784d3896eb1709489c0">findDataBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A) const</td></tr>
<tr class="memdesc:a92f0086f28d68784d3896eb1709489c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that start at an address.  <a href="classgtirb_1_1_byte_interval.html#a92f0086f28d68784d3896eb1709489c0">More...</a><br /></td></tr>
<tr class="separator:a92f0086f28d68784d3896eb1709489c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d73a66820013d9d172acbb5af82469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ac9d73a66820013d9d172acbb5af82469">findDataBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> Low, <a class="el" href="classgtirb_1_1_addr.html">Addr</a> High)</td></tr>
<tr class="memdesc:ac9d73a66820013d9d172acbb5af82469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that start between a range of addresses.  <a href="classgtirb_1_1_byte_interval.html#ac9d73a66820013d9d172acbb5af82469">More...</a><br /></td></tr>
<tr class="separator:ac9d73a66820013d9d172acbb5af82469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44153cf66e388941852db0525b6953b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ad44153cf66e388941852db0525b6953b">findDataBlocksAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> Low, <a class="el" href="classgtirb_1_1_addr.html">Addr</a> High) const</td></tr>
<tr class="memdesc:ad44153cf66e388941852db0525b6953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that start between a range of addresses.  <a href="classgtirb_1_1_byte_interval.html#ad44153cf66e388941852db0525b6953b">More...</a><br /></td></tr>
<tr class="separator:ad44153cf66e388941852db0525b6953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8968d98157d5273533b427407051c2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a8968d98157d5273533b427407051c2e2">findDataBlocksAtOffset</a> (uint64_t Low, uint64_t High)</td></tr>
<tr class="memdesc:a8968d98157d5273533b427407051c2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that start between a range of offsets.  <a href="classgtirb_1_1_byte_interval.html#a8968d98157d5273533b427407051c2e2">More...</a><br /></td></tr>
<tr class="separator:a8968d98157d5273533b427407051c2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb4098b3ec6298f73db58f251040428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a3bb4098b3ec6298f73db58f251040428">findDataBlocksAtOffset</a> (uint64_t Low, uint64_t High) const</td></tr>
<tr class="memdesc:a3bb4098b3ec6298f73db58f251040428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that start between a range of offsets.  <a href="classgtirb_1_1_byte_interval.html#a3bb4098b3ec6298f73db58f251040428">More...</a><br /></td></tr>
<tr class="separator:a3bb4098b3ec6298f73db58f251040428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca945b537a6e75014baa75d6f8c417b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a2ca945b537a6e75014baa75d6f8c417b">findDataBlocksAtOffset</a> (uint64_t Off)</td></tr>
<tr class="memdesc:a2ca945b537a6e75014baa75d6f8c417b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that start at an offset.  <a href="classgtirb_1_1_byte_interval.html#a2ca945b537a6e75014baa75d6f8c417b">More...</a><br /></td></tr>
<tr class="separator:a2ca945b537a6e75014baa75d6f8c417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d51e7fdb6cc98c70875e2191ebf5284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a4d51e7fdb6cc98c70875e2191ebf5284">findDataBlocksAtOffset</a> (uint64_t Off) const</td></tr>
<tr class="memdesc:a4d51e7fdb6cc98c70875e2191ebf5284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that start at an offset.  <a href="classgtirb_1_1_byte_interval.html#a4d51e7fdb6cc98c70875e2191ebf5284">More...</a><br /></td></tr>
<tr class="separator:a4d51e7fdb6cc98c70875e2191ebf5284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3da87af28426df76b47d0fee4f5c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a306f0089a518e8c7f70125f8ffd5bf8e">data_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a0a3da87af28426df76b47d0fee4f5c8f">findDataBlocksOn</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A)</td></tr>
<tr class="memdesc:a0a3da87af28426df76b47d0fee4f5c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that have bytes that lie within the address specified.  <a href="classgtirb_1_1_byte_interval.html#a0a3da87af28426df76b47d0fee4f5c8f">More...</a><br /></td></tr>
<tr class="separator:a0a3da87af28426df76b47d0fee4f5c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad061d5a26337ca9def02b80a75b0cf9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a07919c9f159f58b568f68bc59b61d43f">const_data_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ad061d5a26337ca9def02b80a75b0cf9e">findDataBlocksOn</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A) const</td></tr>
<tr class="memdesc:ad061d5a26337ca9def02b80a75b0cf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that have bytes that lie within the address specified.  <a href="classgtirb_1_1_byte_interval.html#ad061d5a26337ca9def02b80a75b0cf9e">More...</a><br /></td></tr>
<tr class="separator:ad061d5a26337ca9def02b80a75b0cf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fee010ddd4b746c158b4fd99b435de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a306f0089a518e8c7f70125f8ffd5bf8e">data_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a58fee010ddd4b746c158b4fd99b435de">findDataBlocksOnOffset</a> (uint64_t Off)</td></tr>
<tr class="memdesc:a58fee010ddd4b746c158b4fd99b435de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that have a byte at the specified offset.  <a href="classgtirb_1_1_byte_interval.html#a58fee010ddd4b746c158b4fd99b435de">More...</a><br /></td></tr>
<tr class="separator:a58fee010ddd4b746c158b4fd99b435de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9d4b8d5b22df7c62214f4adb7aae05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a07919c9f159f58b568f68bc59b61d43f">const_data_block_subrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a9f9d4b8d5b22df7c62214f4adb7aae05">findDataBlocksOnOffset</a> (uint64_t Off) const</td></tr>
<tr class="memdesc:a9f9d4b8d5b22df7c62214f4adb7aae05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the data blocks that have a byte at the specified offset.  <a href="classgtirb_1_1_byte_interval.html#a9f9d4b8d5b22df7c62214f4adb7aae05">More...</a><br /></td></tr>
<tr class="separator:a9f9d4b8d5b22df7c62214f4adb7aae05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00d181320247c9f1db803132bb898b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ac00d181320247c9f1db803132bb898b5">findSymbolicExpressionsAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A)</td></tr>
<tr class="memdesc:ac00d181320247c9f1db803132bb898b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the symbolic expressions that start at an address.  <a href="classgtirb_1_1_byte_interval.html#ac00d181320247c9f1db803132bb898b5">More...</a><br /></td></tr>
<tr class="separator:ac00d181320247c9f1db803132bb898b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58bdb347d2b47963d58a291a90b61c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ae58bdb347d2b47963d58a291a90b61c1">findSymbolicExpressionsAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> A) const</td></tr>
<tr class="memdesc:ae58bdb347d2b47963d58a291a90b61c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the symbolic expressions that start at an address.  <a href="classgtirb_1_1_byte_interval.html#ae58bdb347d2b47963d58a291a90b61c1">More...</a><br /></td></tr>
<tr class="separator:ae58bdb347d2b47963d58a291a90b61c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e5ed8ca050ba674c8c9b53fd98df5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ae4e5ed8ca050ba674c8c9b53fd98df5c">findSymbolicExpressionsAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> Low, <a class="el" href="classgtirb_1_1_addr.html">Addr</a> High)</td></tr>
<tr class="memdesc:ae4e5ed8ca050ba674c8c9b53fd98df5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the symbolic expressions that start between a range of addresses.  <a href="classgtirb_1_1_byte_interval.html#ae4e5ed8ca050ba674c8c9b53fd98df5c">More...</a><br /></td></tr>
<tr class="separator:ae4e5ed8ca050ba674c8c9b53fd98df5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1f7069dca14305e44507d525a296a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a4a1f7069dca14305e44507d525a296a3">findSymbolicExpressionsAt</a> (<a class="el" href="classgtirb_1_1_addr.html">Addr</a> Low, <a class="el" href="classgtirb_1_1_addr.html">Addr</a> High) const</td></tr>
<tr class="memdesc:a4a1f7069dca14305e44507d525a296a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the symbolic expressions that start between a range of addresses.  <a href="classgtirb_1_1_byte_interval.html#a4a1f7069dca14305e44507d525a296a3">More...</a><br /></td></tr>
<tr class="separator:a4a1f7069dca14305e44507d525a296a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd437910da74b362192d61adade479a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a9cd437910da74b362192d61adade479a">findSymbolicExpressionsAtOffset</a> (uint64_t Low, uint64_t High)</td></tr>
<tr class="memdesc:a9cd437910da74b362192d61adade479a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the symbolic expressions that start between a range of offsets.  <a href="classgtirb_1_1_byte_interval.html#a9cd437910da74b362192d61adade479a">More...</a><br /></td></tr>
<tr class="separator:a9cd437910da74b362192d61adade479a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec55cc1af43b9f343665e0c084ade13c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aec55cc1af43b9f343665e0c084ade13c">findSymbolicExpressionsAtOffset</a> (uint64_t Low, uint64_t High) const</td></tr>
<tr class="memdesc:aec55cc1af43b9f343665e0c084ade13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the symbolic expressions that start between a range of offsets.  <a href="classgtirb_1_1_byte_interval.html#aec55cc1af43b9f343665e0c084ade13c">More...</a><br /></td></tr>
<tr class="separator:aec55cc1af43b9f343665e0c084ade13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70e6e2067b51a1e443b9dd0c95c913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a9d70e6e2067b51a1e443b9dd0c95c913">findSymbolicExpressionsAtOffset</a> (uint64_t Off)</td></tr>
<tr class="memdesc:a9d70e6e2067b51a1e443b9dd0c95c913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the symbolic expressions that start at an offset.  <a href="classgtirb_1_1_byte_interval.html#a9d70e6e2067b51a1e443b9dd0c95c913">More...</a><br /></td></tr>
<tr class="separator:a9d70e6e2067b51a1e443b9dd0c95c913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abcdd7487176ad98e17d7d956e1a06e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a3abcdd7487176ad98e17d7d956e1a06e">findSymbolicExpressionsAtOffset</a> (uint64_t Off) const</td></tr>
<tr class="memdesc:a3abcdd7487176ad98e17d7d956e1a06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the symbolic expressions that start at an offset.  <a href="classgtirb_1_1_byte_interval.html#a3abcdd7487176ad98e17d7d956e1a06e">More...</a><br /></td></tr>
<tr class="separator:a3abcdd7487176ad98e17d7d956e1a06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf13ececea7d2b943402feeb4f1aae35"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classgtirb_1_1_addr.html">Addr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aaf13ececea7d2b943402feeb4f1aae35">getAddress</a> () const</td></tr>
<tr class="memdesc:aaf13ececea7d2b943402feeb4f1aae35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fixed address of this interval, if present.  <a href="classgtirb_1_1_byte_interval.html#aaf13ececea7d2b943402feeb4f1aae35">More...</a><br /></td></tr>
<tr class="separator:aaf13ececea7d2b943402feeb4f1aae35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573a5fcaa3a8feeb108cb42f3d5b0c18"><td class="memItemLeft" align="right" valign="top">boost::endian::order&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a573a5fcaa3a8feeb108cb42f3d5b0c18">getBoostEndianOrder</a> () const</td></tr>
<tr class="memdesc:a573a5fcaa3a8feeb108cb42f3d5b0c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <code>boost::endian::order</code> of this module, suitable for passing to the <code>bytes</code> iterator.  <a href="classgtirb_1_1_byte_interval.html#a573a5fcaa3a8feeb108cb42f3d5b0c18">More...</a><br /></td></tr>
<tr class="separator:a573a5fcaa3a8feeb108cb42f3d5b0c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c073ce08ee11ac7a435f155239eeaf2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a9c073ce08ee11ac7a435f155239eeaf2">getInitializedSize</a> () const</td></tr>
<tr class="memdesc:a9c073ce08ee11ac7a435f155239eeaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of initialized bytes in this interval.  <a href="classgtirb_1_1_byte_interval.html#a9c073ce08ee11ac7a435f155239eeaf2">More...</a><br /></td></tr>
<tr class="separator:a9c073ce08ee11ac7a435f155239eeaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050df8ed14b0cbd338db6b4b1cb10b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_section.html">Section</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a050df8ed14b0cbd338db6b4b1cb10b59">getSection</a> ()</td></tr>
<tr class="memdesc:a050df8ed14b0cbd338db6b4b1cb10b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classgtirb_1_1_section.html">Section</a> this byte interval belongs to.  <a href="classgtirb_1_1_byte_interval.html#a050df8ed14b0cbd338db6b4b1cb10b59">More...</a><br /></td></tr>
<tr class="separator:a050df8ed14b0cbd338db6b4b1cb10b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d449b4c06fd818a5def623c758d716"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgtirb_1_1_section.html">Section</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aa9d449b4c06fd818a5def623c758d716">getSection</a> () const</td></tr>
<tr class="memdesc:aa9d449b4c06fd818a5def623c758d716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classgtirb_1_1_section.html">Section</a> this byte interval belongs to.  <a href="classgtirb_1_1_byte_interval.html#aa9d449b4c06fd818a5def623c758d716">More...</a><br /></td></tr>
<tr class="separator:aa9d449b4c06fd818a5def623c758d716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403c7f5605adeef32d12573a830b9dc5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a403c7f5605adeef32d12573a830b9dc5">getSize</a> () const</td></tr>
<tr class="memdesc:a403c7f5605adeef32d12573a830b9dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of this interval in bytes.  <a href="classgtirb_1_1_byte_interval.html#a403c7f5605adeef32d12573a830b9dc5">More...</a><br /></td></tr>
<tr class="separator:a403c7f5605adeef32d12573a830b9dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2095ccd582e266d431cca99e624825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a4b2095ccd582e266d431cca99e624825">getSymbolicExpression</a> (uint64_t Off)</td></tr>
<tr class="memdesc:a4b2095ccd582e266d431cca99e624825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the symbolic expression at the given offset, if present.  <a href="classgtirb_1_1_byte_interval.html#a4b2095ccd582e266d431cca99e624825">More...</a><br /></td></tr>
<tr class="separator:a4b2095ccd582e266d431cca99e624825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ac8848323b27aebe2785b5b77d8263"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a58ac8848323b27aebe2785b5b77d8263">getSymbolicExpression</a> (uint64_t Off) const</td></tr>
<tr class="memdesc:a58ac8848323b27aebe2785b5b77d8263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the symbolic expression at the given offset, if present.  <a href="classgtirb_1_1_byte_interval.html#a58ac8848323b27aebe2785b5b77d8263">More...</a><br /></td></tr>
<tr class="separator:a58ac8848323b27aebe2785b5b77d8263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d532a81776e4896f8b8604f9f8cb73"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74d532a81776e4896f8b8604f9f8cb73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a74d532a81776e4896f8b8604f9f8cb73">insertBytes</a> (const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt; Pos, const T &amp;X)</td></tr>
<tr class="memdesc:a74d532a81776e4896f8b8604f9f8cb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a single datum into this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a74d532a81776e4896f8b8604f9f8cb73">More...</a><br /></td></tr>
<tr class="separator:a74d532a81776e4896f8b8604f9f8cb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04f93e068365bd6451a514c3235c192"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad04f93e068365bd6451a514c3235c192"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ad04f93e068365bd6451a514c3235c192">insertBytes</a> (const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt; Pos, const T &amp;X, boost::endian::order VectorOrder, boost::endian::order ElementOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:ad04f93e068365bd6451a514c3235c192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a single datum into this byte vector.  <a href="classgtirb_1_1_byte_interval.html#ad04f93e068365bd6451a514c3235c192">More...</a><br /></td></tr>
<tr class="separator:ad04f93e068365bd6451a514c3235c192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745a56af06de2e711ce4ebfe36fdb2a5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename InputIterator &gt; </td></tr>
<tr class="memitem:a745a56af06de2e711ce4ebfe36fdb2a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a745a56af06de2e711ce4ebfe36fdb2a5">insertBytes</a> (const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt; Pos, InputIterator Begin, InputIterator End)</td></tr>
<tr class="memdesc:a745a56af06de2e711ce4ebfe36fdb2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a745a56af06de2e711ce4ebfe36fdb2a5">More...</a><br /></td></tr>
<tr class="separator:a745a56af06de2e711ce4ebfe36fdb2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff09ea69677f7139527ed42969156090"><td class="memTemplParams" colspan="2">template&lt;typename T , typename InputIterator &gt; </td></tr>
<tr class="memitem:aff09ea69677f7139527ed42969156090"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aff09ea69677f7139527ed42969156090">insertBytes</a> (const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt; Pos, InputIterator Begin, InputIterator End, boost::endian::order VectorOrder, boost::endian::order ElementsOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:aff09ea69677f7139527ed42969156090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into this byte vector.  <a href="classgtirb_1_1_byte_interval.html#aff09ea69677f7139527ed42969156090">More...</a><br /></td></tr>
<tr class="separator:aff09ea69677f7139527ed42969156090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b6ab4f1b6e48498eab46ff2ea7f146"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6b6ab4f1b6e48498eab46ff2ea7f146"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#af6b6ab4f1b6e48498eab46ff2ea7f146">rawBytes</a> ()</td></tr>
<tr class="memdesc:af6b6ab4f1b6e48498eab46ff2ea7f146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw data underlying this byte vector.  <a href="classgtirb_1_1_byte_interval.html#af6b6ab4f1b6e48498eab46ff2ea7f146">More...</a><br /></td></tr>
<tr class="separator:af6b6ab4f1b6e48498eab46ff2ea7f146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec7c816f4d210543007964ba1d69050"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ec7c816f4d210543007964ba1d69050"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a7ec7c816f4d210543007964ba1d69050">rawBytes</a> () const</td></tr>
<tr class="memdesc:a7ec7c816f4d210543007964ba1d69050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw data underlying this byte vector.  <a href="classgtirb_1_1_byte_interval.html#a7ec7c816f4d210543007964ba1d69050">More...</a><br /></td></tr>
<tr class="separator:a7ec7c816f4d210543007964ba1d69050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac76766e70c9e455d8c2e740fc5d4a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegtirb.html#ad7db2026ea49abab0562fd0cf344a00b">ChangeStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aeac76766e70c9e455d8c2e740fc5d4a8">removeBlock</a> (<a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> *B)</td></tr>
<tr class="memdesc:aeac76766e70c9e455d8c2e740fc5d4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a block from this interval.  <a href="classgtirb_1_1_byte_interval.html#aeac76766e70c9e455d8c2e740fc5d4a8">More...</a><br /></td></tr>
<tr class="separator:aeac76766e70c9e455d8c2e740fc5d4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1f05a18d729d1febd5acd410c3c2ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegtirb.html#ad7db2026ea49abab0562fd0cf344a00b">ChangeStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ace1f05a18d729d1febd5acd410c3c2ff">removeBlock</a> (<a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> *B)</td></tr>
<tr class="memdesc:ace1f05a18d729d1febd5acd410c3c2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a block from this interval.  <a href="classgtirb_1_1_byte_interval.html#ace1f05a18d729d1febd5acd410c3c2ff">More...</a><br /></td></tr>
<tr class="separator:ace1f05a18d729d1febd5acd410c3c2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2d53d3934c8dd5c6db3869ed625c64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#afc2d53d3934c8dd5c6db3869ed625c64">removeSymbolicExpression</a> (uint64_t Off)</td></tr>
<tr class="memdesc:afc2d53d3934c8dd5c6db3869ed625c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> at the given offset, if present.  <a href="classgtirb_1_1_byte_interval.html#afc2d53d3934c8dd5c6db3869ed625c64">More...</a><br /></td></tr>
<tr class="separator:afc2d53d3934c8dd5c6db3869ed625c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a2a39cab63acb536e44eb36ffd5278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a06a2a39cab63acb536e44eb36ffd5278">setAddress</a> (std::optional&lt; <a class="el" href="classgtirb_1_1_addr.html">Addr</a> &gt; A)</td></tr>
<tr class="memdesc:a06a2a39cab63acb536e44eb36ffd5278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or clear the address of this interval.  <a href="classgtirb_1_1_byte_interval.html#a06a2a39cab63acb536e44eb36ffd5278">More...</a><br /></td></tr>
<tr class="separator:a06a2a39cab63acb536e44eb36ffd5278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9468f6913c9aa8c64cfcd91e3d455005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a9468f6913c9aa8c64cfcd91e3d455005">setInitializedSize</a> (uint64_t S)</td></tr>
<tr class="memdesc:a9468f6913c9aa8c64cfcd91e3d455005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of initialized bytes in this interval.  <a href="classgtirb_1_1_byte_interval.html#a9468f6913c9aa8c64cfcd91e3d455005">More...</a><br /></td></tr>
<tr class="separator:a9468f6913c9aa8c64cfcd91e3d455005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40baa1fdcd468fd8f6f52f2eb1cce565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a40baa1fdcd468fd8f6f52f2eb1cce565">setSize</a> (uint64_t S)</td></tr>
<tr class="memdesc:a40baa1fdcd468fd8f6f52f2eb1cce565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of this interval.  <a href="classgtirb_1_1_byte_interval.html#a40baa1fdcd468fd8f6f52f2eb1cce565">More...</a><br /></td></tr>
<tr class="separator:a40baa1fdcd468fd8f6f52f2eb1cce565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bc61b0a1617d464b00aaab1a794cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a57bc61b0a1617d464b00aaab1a794cd2">symbolic_expressions</a> ()</td></tr>
<tr class="memdesc:a57bc61b0a1617d464b00aaab1a794cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range of the <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects in this interval.  <a href="classgtirb_1_1_byte_interval.html#a57bc61b0a1617d464b00aaab1a794cd2">More...</a><br /></td></tr>
<tr class="separator:a57bc61b0a1617d464b00aaab1a794cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7fd35f3ba13474403cbf15baa6b45d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#acb7fd35f3ba13474403cbf15baa6b45d">symbolic_expressions</a> () const</td></tr>
<tr class="memdesc:acb7fd35f3ba13474403cbf15baa6b45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const range of the <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects in this interval.  <a href="classgtirb_1_1_byte_interval.html#acb7fd35f3ba13474403cbf15baa6b45d">More...</a><br /></td></tr>
<tr class="separator:acb7fd35f3ba13474403cbf15baa6b45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4e81c32e735376131fc878366b1de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ae3e013b5817c7046b1791904debac22e">symbolic_expression_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a1c4e81c32e735376131fc878366b1de9">symbolic_expressions_begin</a> ()</td></tr>
<tr class="memdesc:a1c4e81c32e735376131fc878366b1de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>.  <a href="classgtirb_1_1_byte_interval.html#a1c4e81c32e735376131fc878366b1de9">More...</a><br /></td></tr>
<tr class="separator:a1c4e81c32e735376131fc878366b1de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e443dae578f8da16f0f7e6ebf7f12b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ad8b707f7e9e50062a468b820d7e79f87">const_symbolic_expression_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#af0e443dae578f8da16f0f7e6ebf7f12b">symbolic_expressions_begin</a> () const</td></tr>
<tr class="memdesc:af0e443dae578f8da16f0f7e6ebf7f12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the first <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>.  <a href="classgtirb_1_1_byte_interval.html#af0e443dae578f8da16f0f7e6ebf7f12b">More...</a><br /></td></tr>
<tr class="separator:af0e443dae578f8da16f0f7e6ebf7f12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5331b945a2c31e33ce9cadb74bd4dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ae3e013b5817c7046b1791904debac22e">symbolic_expression_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#abb5331b945a2c31e33ce9cadb74bd4dd">symbolic_expressions_end</a> ()</td></tr>
<tr class="memdesc:abb5331b945a2c31e33ce9cadb74bd4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the element following the last <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>.  <a href="classgtirb_1_1_byte_interval.html#abb5331b945a2c31e33ce9cadb74bd4dd">More...</a><br /></td></tr>
<tr class="separator:abb5331b945a2c31e33ce9cadb74bd4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa5a64005b3a7e51a989ea51080aeb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html#ad8b707f7e9e50062a468b820d7e79f87">const_symbolic_expression_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a0aa5a64005b3a7e51a989ea51080aeb6">symbolic_expressions_end</a> () const</td></tr>
<tr class="memdesc:a0aa5a64005b3a7e51a989ea51080aeb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the element following the last <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>.  <a href="classgtirb_1_1_byte_interval.html#a0aa5a64005b3a7e51a989ea51080aeb6">More...</a><br /></td></tr>
<tr class="separator:a0aa5a64005b3a7e51a989ea51080aeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgtirb_1_1_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgtirb_1_1_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgtirb_1_1_node.html">gtirb::Node</a></td></tr>
<tr class="memitem:a36a7eb184c437e329cd6628abd7981a3 inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a36a7eb184c437e329cd6628abd7981a3">Node</a> (const <a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;)=delete</td></tr>
<tr class="memdesc:a36a7eb184c437e329cd6628abd7981a3 inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying Nodes is explicitly disabled.  <a href="classgtirb_1_1_node.html#a36a7eb184c437e329cd6628abd7981a3">More...</a><br /></td></tr>
<tr class="separator:a36a7eb184c437e329cd6628abd7981a3 inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3e3cc413be907d848fbd839acd937c inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a9b3e3cc413be907d848fbd839acd937c">Node</a> (<a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a9b3e3cc413be907d848fbd839acd937c inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructing Nodes is explicitly disabled.  <a href="classgtirb_1_1_node.html#a9b3e3cc413be907d848fbd839acd937c">More...</a><br /></td></tr>
<tr class="separator:a9b3e3cc413be907d848fbd839acd937c inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2198c2f14d4b1bc01dfe50b0c10bdfed inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a2198c2f14d4b1bc01dfe50b0c10bdfed">~Node</a> () noexcept</td></tr>
<tr class="memdesc:a2198c2f14d4b1bc01dfe50b0c10bdfed inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up resources no longer needed by the <a class="el" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy.">Node</a> object.  <a href="classgtirb_1_1_node.html#a2198c2f14d4b1bc01dfe50b0c10bdfed">More...</a><br /></td></tr>
<tr class="separator:a2198c2f14d4b1bc01dfe50b0c10bdfed inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c1f7fbac43e778445e6a710a401700 inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a05c1f7fbac43e778445e6a710a401700">getUUID</a> () const</td></tr>
<tr class="memdesc:a05c1f7fbac43e778445e6a710a401700 inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Universally Unique ID (UUID) for <code>this</code>.  <a href="classgtirb_1_1_node.html#a05c1f7fbac43e778445e6a710a401700">More...</a><br /></td></tr>
<tr class="separator:a05c1f7fbac43e778445e6a710a401700 inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada843ff6ad535a3f82650a4f580255e3 inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#ada843ff6ad535a3f82650a4f580255e3">operator=</a> (const <a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;)=delete</td></tr>
<tr class="memdesc:ada843ff6ad535a3f82650a4f580255e3 inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying Nodes is explicilty disabled.  <a href="classgtirb_1_1_node.html#ada843ff6ad535a3f82650a4f580255e3">More...</a><br /></td></tr>
<tr class="separator:ada843ff6ad535a3f82650a4f580255e3 inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ffe7e5d11d133b6a77a22ffc208e1c inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#aa2ffe7e5d11d133b6a77a22ffc208e1c">operator=</a> (<a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:aa2ffe7e5d11d133b6a77a22ffc208e1c inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigning Nodes is explicilty disabled.  <a href="classgtirb_1_1_node.html#aa2ffe7e5d11d133b6a77a22ffc208e1c">More...</a><br /></td></tr>
<tr class="separator:aa2ffe7e5d11d133b6a77a22ffc208e1c inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a18925fb9dca97989ae51261de981deed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a18925fb9dca97989ae51261de981deed">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C)</td></tr>
<tr class="memdesc:a18925fb9dca97989ae51261de981deed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an unitialized <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object.  <a href="classgtirb_1_1_byte_interval.html#a18925fb9dca97989ae51261de981deed">More...</a><br /></td></tr>
<tr class="separator:a18925fb9dca97989ae51261de981deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b13dd0f8c68c067676701fe16f6b37f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a6b13dd0f8c68c067676701fe16f6b37f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a6b13dd0f8c68c067676701fe16f6b37f">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, InputIterator Begin, InputIterator End, std::optional&lt; uint64_t &gt; Size=std::nullopt, std::optional&lt; uint64_t &gt; InitSize=std::nullopt)</td></tr>
<tr class="memdesc:a6b13dd0f8c68c067676701fe16f6b37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object.  <a href="classgtirb_1_1_byte_interval.html#a6b13dd0f8c68c067676701fe16f6b37f">More...</a><br /></td></tr>
<tr class="separator:a6b13dd0f8c68c067676701fe16f6b37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b712e0c5309786aff95f5e090be9653"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a5b712e0c5309786aff95f5e090be9653"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a5b712e0c5309786aff95f5e090be9653">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, std::optional&lt; <a class="el" href="classgtirb_1_1_addr.html">Addr</a> &gt; Address, InputIterator Begin, InputIterator End, std::optional&lt; uint64_t &gt; Size=std::nullopt, std::optional&lt; uint64_t &gt; InitSize=std::nullopt)</td></tr>
<tr class="memdesc:a5b712e0c5309786aff95f5e090be9653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object.  <a href="classgtirb_1_1_byte_interval.html#a5b712e0c5309786aff95f5e090be9653">More...</a><br /></td></tr>
<tr class="separator:a5b712e0c5309786aff95f5e090be9653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493bc75db2c0543f6bf8d814e73a90d1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a493bc75db2c0543f6bf8d814e73a90d1">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, std::optional&lt; <a class="el" href="classgtirb_1_1_addr.html">Addr</a> &gt; Address, uint64_t Size=0, std::optional&lt; uint64_t &gt; InitSize=std::nullopt)</td></tr>
<tr class="memdesc:a493bc75db2c0543f6bf8d814e73a90d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object.  <a href="classgtirb_1_1_byte_interval.html#a493bc75db2c0543f6bf8d814e73a90d1">More...</a><br /></td></tr>
<tr class="separator:a493bc75db2c0543f6bf8d814e73a90d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb982ae948d600730d4837f50c3ea1ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#acb982ae948d600730d4837f50c3ea1ce">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, uint64_t Size, std::optional&lt; uint64_t &gt; InitSize=std::nullopt)</td></tr>
<tr class="memdesc:acb982ae948d600730d4837f50c3ea1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object.  <a href="classgtirb_1_1_byte_interval.html#acb982ae948d600730d4837f50c3ea1ce">More...</a><br /></td></tr>
<tr class="separator:acb982ae948d600730d4837f50c3ea1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classgtirb_1_1_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classgtirb_1_1_node')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classgtirb_1_1_node.html">gtirb::Node</a></td></tr>
<tr class="memitem:ab34e75309d3cdbae6ae783483152bf1c inherit pub_static_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#ab34e75309d3cdbae6ae783483152bf1c">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C)</td></tr>
<tr class="memdesc:ab34e75309d3cdbae6ae783483152bf1c inherit pub_static_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy.">Node</a> object in its default state.  <a href="classgtirb_1_1_node.html#ab34e75309d3cdbae6ae783483152bf1c">More...</a><br /></td></tr>
<tr class="separator:ab34e75309d3cdbae6ae783483152bf1c inherit pub_static_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04cfa2271347cdeb3a547f829141380 inherit pub_static_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classgtirb_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#ad04cfa2271347cdeb3a547f829141380">getByUUID</a> (const <a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;Uuid)</td></tr>
<tr class="memdesc:ad04cfa2271347cdeb3a547f829141380 inherit pub_static_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a node by its UUID.  <a href="classgtirb_1_1_node.html#ad04cfa2271347cdeb3a547f829141380">More...</a><br /></td></tr>
<tr class="separator:ad04cfa2271347cdeb3a547f829141380 inherit pub_static_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea06820c30b4b70b97b317877e86d17 inherit pub_static_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#abea06820c30b4b70b97b317877e86d17">getByUUID</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;Uuid)</td></tr>
<tr class="memdesc:abea06820c30b4b70b97b317877e86d17 inherit pub_static_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a node by its UUID.  <a href="classgtirb_1_1_node.html#abea06820c30b4b70b97b317877e86d17">More...</a><br /></td></tr>
<tr class="separator:abea06820c30b4b70b97b317877e86d17 inherit pub_static_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a34055062091a7a77b0032d904a2844ad"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a34055062091a7a77b0032d904a2844ad">CodeBlock</a></td></tr>
<tr class="separator:a34055062091a7a77b0032d904a2844ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26c806e60ca4a0547680edb68f6e39b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#ac26c806e60ca4a0547680edb68f6e39b">Context</a></td></tr>
<tr class="separator:ac26c806e60ca4a0547680edb68f6e39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aac6b337c40507a2c713bcafc41b95b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a2aac6b337c40507a2c713bcafc41b95b">DataBlock</a></td></tr>
<tr class="separator:a2aac6b337c40507a2c713bcafc41b95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f639900c480510650969df9c74d17d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a21f639900c480510650969df9c74d17d">Module</a></td></tr>
<tr class="separator:a21f639900c480510650969df9c74d17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd6fc422149e1c8416770631b28d40c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#a0bd6fc422149e1c8416770631b28d40c">Section</a></td></tr>
<tr class="separator:a0bd6fc422149e1c8416770631b28d40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7995861301f2eefb390acea47c34a9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_byte_interval.html#aca7995861301f2eefb390acea47c34a9">SerializationTestHarness</a></td></tr>
<tr class="separator:aca7995861301f2eefb390acea47c34a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A contiguous region of bytes in a binary. </p>
<p>A <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> defines a relative ordering for a group of Block objects, optionally at a fixed address in memory. It also stores the bytes associated with these blocks.</p>
<p>If two blocks are in two different ByteIntervals, then it should be considered safe (that is, preserving of program semantics) to move one block relative to the other in memory. If two blocks are in the same <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a>, then it should be considered unknown if moving the two blocks relative to one another in memory is a safe operation. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a906497ecbe80ec11c48115066609face"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906497ecbe80ec11c48115066609face">&#9670;&nbsp;</a></span>block_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a906497ecbe80ec11c48115066609face">gtirb::ByteInterval::block_iterator</a> =  boost::transform_iterator&lt;BlockToNode&lt;<a class="el" href="classgtirb_1_1_node.html">Node</a>&gt;, BlockSet::index&lt;by_offset&gt;::type::iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over Block objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, their order is not specified. </p>

</div>
</div>
<a id="a47b9128195d9da23d68d66669049bdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b9128195d9da23d68d66669049bdf1">&#9670;&nbsp;</a></span>block_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">gtirb::ByteInterval::block_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#a906497ecbe80ec11c48115066609face">block_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range of Block objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, their order is not specified. </p>

</div>
</div>
<a id="a99b01abb4d4050e12ac762d248d1f5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b01abb4d4050e12ac762d248d1f5a1">&#9670;&nbsp;</a></span>block_subrange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a99b01abb4d4050e12ac762d248d1f5a1">gtirb::ByteInterval::block_subrange</a> =  boost::iterator_range&lt;boost::transform_iterator&lt; BlockToNode&lt;<a class="el" href="classgtirb_1_1_node.html">Node</a>&gt;, BlockIntMap::codomain_type::iterator&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sub-range of blocks overlapping an address or range of addreses. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="a21e0a4733ed217016369e4a56188947f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e0a4733ed217016369e4a56188947f">&#9670;&nbsp;</a></span>bytes_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">gtirb::ByteInterval::bytes_iterator</a> =  BytesBaseIterator&lt;<a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a336fa6e85522d894640e366e687ac899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336fa6e85522d894640e366e687ac899">&#9670;&nbsp;</a></span>bytes_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">gtirb::ByteInterval::bytes_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range over bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5616996099d2349bf3808b69f35e0267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5616996099d2349bf3808b69f35e0267">&#9670;&nbsp;</a></span>code_block_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a5616996099d2349bf3808b69f35e0267">gtirb::ByteInterval::code_block_iterator</a> =  boost::transform_iterator&lt; BlockToNode&lt;<a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>&gt;, boost::filter_iterator&lt;BlockKindEquals&lt;Node::Kind::CodeBlock&gt;, BlockSet::index&lt;by_offset&gt;::type::iterator&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="aade3e2c337788ff115b5547c795ea9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade3e2c337788ff115b5547c795ea9c9">&#9670;&nbsp;</a></span>code_block_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">gtirb::ByteInterval::code_block_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#a5616996099d2349bf3808b69f35e0267">code_block_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="a81e2f48c16615b2f9c2c84daaa3c3cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e2f48c16615b2f9c2c84daaa3c3cda">&#9670;&nbsp;</a></span>code_block_subrange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a81e2f48c16615b2f9c2c84daaa3c3cda">gtirb::ByteInterval::code_block_subrange</a> =  boost::iterator_range&lt;boost::transform_iterator&lt; BlockToNode&lt;<a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>&gt;, boost::filter_iterator&lt; BlockKindEquals&lt;Node::Kind::CodeBlock&gt;, boost::indirect_iterator&lt;BlockIntMap::codomain_type::iterator&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sub-range of code blocks overlapping an address or range of addreses. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="aeb7a62cf27007ec7f00120e86d11273e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7a62cf27007ec7f00120e86d11273e">&#9670;&nbsp;</a></span>const_block_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#aeb7a62cf27007ec7f00120e86d11273e">gtirb::ByteInterval::const_block_iterator</a> =  boost::transform_iterator&lt; BlockToNode&lt;const <a class="el" href="classgtirb_1_1_node.html">Node</a>&gt;, BlockSet::index&lt;by_offset&gt;::type::const_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator over Block objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="aecb2273d4049f8e88ee1901e80e872f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb2273d4049f8e88ee1901e80e872f8">&#9670;&nbsp;</a></span>const_block_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">gtirb::ByteInterval::const_block_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#aeb7a62cf27007ec7f00120e86d11273e">const_block_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const range of Block objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="a0ce195b80ff3bccce7f426c985a49014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce195b80ff3bccce7f426c985a49014">&#9670;&nbsp;</a></span>const_block_subrange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a0ce195b80ff3bccce7f426c985a49014">gtirb::ByteInterval::const_block_subrange</a> =  boost::iterator_range&lt;boost::transform_iterator&lt; BlockToNode&lt;const <a class="el" href="classgtirb_1_1_node.html">Node</a>&gt;, BlockIntMap::codomain_type::const_iterator&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const sub-range of blocks overlapping an address or range of addreses. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="ac56b387cd5cdb902b2ecb0bc1a85103f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56b387cd5cdb902b2ecb0bc1a85103f">&#9670;&nbsp;</a></span>const_bytes_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">gtirb::ByteInterval::const_bytes_iterator</a> =  BytesBaseIterator&lt;const <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator over bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2c13a9122d82ff91df93cefaff12e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c13a9122d82ff91df93cefaff12e47">&#9670;&nbsp;</a></span>const_bytes_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">gtirb::ByteInterval::const_bytes_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const range over bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41e6b824d4be6f520ad00d485ea1540c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e6b824d4be6f520ad00d485ea1540c">&#9670;&nbsp;</a></span>const_code_block_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a41e6b824d4be6f520ad00d485ea1540c">gtirb::ByteInterval::const_code_block_iterator</a> =  boost::transform_iterator&lt; BlockToNode&lt;const <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>&gt;, boost::filter_iterator&lt;BlockKindEquals&lt;Node::Kind::CodeBlock&gt;, BlockSet::index&lt;by_offset&gt;::type::const_iterator&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator over <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="a66cf4ad54f003fc78102cca1ddb85b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cf4ad54f003fc78102cca1ddb85b18">&#9670;&nbsp;</a></span>const_code_block_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">gtirb::ByteInterval::const_code_block_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#a41e6b824d4be6f520ad00d485ea1540c">const_code_block_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="a65a2c7a6e0289bb8c81506131f4c2dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a2c7a6e0289bb8c81506131f4c2dc6">&#9670;&nbsp;</a></span>const_code_block_subrange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a65a2c7a6e0289bb8c81506131f4c2dc6">gtirb::ByteInterval::const_code_block_subrange</a> =  boost::iterator_range&lt;boost::transform_iterator&lt; BlockToNode&lt;const <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>&gt;, boost::filter_iterator&lt; BlockKindEquals&lt;Node::Kind::CodeBlock&gt;, boost::indirect_iterator&lt; BlockIntMap::codomain_type::const_iterator&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const sub-range of code blocks overlapping an address or range of addreses. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="aba6ec5081f685d60287e0eb89cf24818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6ec5081f685d60287e0eb89cf24818">&#9670;&nbsp;</a></span>const_data_block_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#aba6ec5081f685d60287e0eb89cf24818">gtirb::ByteInterval::const_data_block_iterator</a> =  boost::transform_iterator&lt; BlockToNode&lt;const <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>&gt;, boost::filter_iterator&lt;BlockKindEquals&lt;Node::Kind::DataBlock&gt;, BlockSet::index&lt;by_offset&gt;::type::const_iterator&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator over <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="a6246849157b58c6860bf2aeb6702ac02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6246849157b58c6860bf2aeb6702ac02">&#9670;&nbsp;</a></span>const_data_block_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">gtirb::ByteInterval::const_data_block_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#aba6ec5081f685d60287e0eb89cf24818">const_data_block_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="a07919c9f159f58b568f68bc59b61d43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07919c9f159f58b568f68bc59b61d43f">&#9670;&nbsp;</a></span>const_data_block_subrange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a07919c9f159f58b568f68bc59b61d43f">gtirb::ByteInterval::const_data_block_subrange</a> =  boost::iterator_range&lt;boost::transform_iterator&lt; BlockToNode&lt;const <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>&gt;, boost::filter_iterator&lt; BlockKindEquals&lt;Node::Kind::DataBlock&gt;, boost::indirect_iterator&lt; BlockIntMap::codomain_type::const_iterator&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const sub-range of data blocks overlapping an address or range of addreses. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="ad8b707f7e9e50062a468b820d7e79f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b707f7e9e50062a468b820d7e79f87">&#9670;&nbsp;</a></span>const_symbolic_expression_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#ad8b707f7e9e50062a468b820d7e79f87">gtirb::ByteInterval::const_symbolic_expression_iterator</a> =  boost::transform_iterator&lt; SymExprPairToElement&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#aa1bbd096535989c0dca8b61951bae925">ConstSymbolicExpressionElement</a>&gt;, SymbolicExpressionMap::const_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator over <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> objects. </p>
<p>Results are yielded in offset order, ascending. </p>

</div>
</div>
<a id="a44d187d303d730cbb3fda3621293b9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d187d303d730cbb3fda3621293b9c0">&#9670;&nbsp;</a></span>const_symbolic_expression_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">gtirb::ByteInterval::const_symbolic_expression_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#ad8b707f7e9e50062a468b820d7e79f87">const_symbolic_expression_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const range of <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> objects. </p>
<p>Results are yielded in offset order, ascending. </p>

</div>
</div>
<a id="aa1bbd096535989c0dca8b61951bae925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bbd096535989c0dca8b61951bae925">&#9670;&nbsp;</a></span>ConstSymbolicExpressionElement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#aa1bbd096535989c0dca8b61951bae925">gtirb::ByteInterval::ConstSymbolicExpressionElement</a> =  SymbolicExpressionElementBase&lt;const <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A symbolic expression paired with the information needed to look up or alter the symbolic expression after the fact. </p>

</div>
</div>
<a id="acba13200137a60aa6d6bfd93eaa6dd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba13200137a60aa6d6bfd93eaa6dd89">&#9670;&nbsp;</a></span>data_block_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#acba13200137a60aa6d6bfd93eaa6dd89">gtirb::ByteInterval::data_block_iterator</a> =  boost::transform_iterator&lt; BlockToNode&lt;<a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>&gt;, boost::filter_iterator&lt;BlockKindEquals&lt;Node::Kind::DataBlock&gt;, BlockSet::index&lt;by_offset&gt;::type::iterator&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="a02fb519c7a9522d6e0f581dd5483dfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fb519c7a9522d6e0f581dd5483dfbf">&#9670;&nbsp;</a></span>data_block_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">gtirb::ByteInterval::data_block_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#acba13200137a60aa6d6bfd93eaa6dd89">data_block_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="a306f0089a518e8c7f70125f8ffd5bf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306f0089a518e8c7f70125f8ffd5bf8e">&#9670;&nbsp;</a></span>data_block_subrange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a306f0089a518e8c7f70125f8ffd5bf8e">gtirb::ByteInterval::data_block_subrange</a> =  boost::iterator_range&lt;boost::transform_iterator&lt; BlockToNode&lt;<a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>&gt;, boost::filter_iterator&lt; BlockKindEquals&lt;Node::Kind::DataBlock&gt;, boost::indirect_iterator&lt;BlockIntMap::codomain_type::iterator&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sub-range of data blocks overlapping an address or range of addreses. </p>
<p>Blocks are yielded in offset order, ascending. If two blocks have the same offset, thier order is not specified. </p>

</div>
</div>
<a id="ae3e013b5817c7046b1791904debac22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e013b5817c7046b1791904debac22e">&#9670;&nbsp;</a></span>symbolic_expression_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#ae3e013b5817c7046b1791904debac22e">gtirb::ByteInterval::symbolic_expression_iterator</a> =  boost::transform_iterator&lt;SymExprPairToElement&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a>&gt;, SymbolicExpressionMap::iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> objects. </p>
<p>Results are yielded in offset order, ascending. </p>

</div>
</div>
<a id="afd12ca596011ad35839c267401d4e588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd12ca596011ad35839c267401d4e588">&#9670;&nbsp;</a></span>symbolic_expression_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">gtirb::ByteInterval::symbolic_expression_range</a> =  boost::iterator_range&lt;<a class="el" href="classgtirb_1_1_byte_interval.html#ae3e013b5817c7046b1791904debac22e">symbolic_expression_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range of <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">SymbolicExpressionElement</a> objects. </p>
<p>Results are yielded in offset order, ascending. </p>

</div>
</div>
<a id="a3e05737b52c2128bd81c4559f9534df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e05737b52c2128bd81c4559f9534df9">&#9670;&nbsp;</a></span>SymbolicExpressionElement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_byte_interval.html#a3e05737b52c2128bd81c4559f9534df9">gtirb::ByteInterval::SymbolicExpressionElement</a> =  SymbolicExpressionElementBase&lt;<a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A symbolic expression paired with the information needed to look up or alter the symbolic expression after the fact. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad239f11f34051bd7c536c3c903738641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad239f11f34051bd7c536c3c903738641">&#9670;&nbsp;</a></span>addBlock() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BlockType* gtirb::ByteInterval::addBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Block of the given type at a given offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BlockType</td><td>Either <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> or <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>. </td></tr>
    <tr><td class="paramname">Args</td><td>The arguments to construct a <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html">Context</a> to use. </td></tr>
    <tr><td class="paramname">O</td><td>The offset to add the new <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> at. </td></tr>
    <tr><td class="paramname">A</td><td>The arguments to construct a <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </dd></dl>

</div>
</div>
<a id="aa8f01446fb6e3fcdea2a4f4c86e915bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f01446fb6e3fcdea2a4f4c86e915bf">&#9670;&nbsp;</a></span>addBlock() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegtirb.html#ad7db2026ea49abab0562fd0cf344a00b">ChangeStatus</a> gtirb::ByteInterval::addBlock </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> *&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a> to be a part of this interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to move the block to. </td></tr>
    <tr><td class="paramname">N</td><td>The block to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ChangeStatus indicating whether the insertion took place (<code>Accepted</code>), was unnecessary because this node already contained the <a class="el" href="classgtirb_1_1_code_block.html" title="A basic block.">CodeBlock</a> (<code>NoChange</code>), or could not be completed (<code>Rejected</code>). </dd></dl>

</div>
</div>
<a id="a019f94b6345c87726872ad9bd5eb664d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019f94b6345c87726872ad9bd5eb664d">&#9670;&nbsp;</a></span>addBlock() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegtirb.html#ad7db2026ea49abab0562fd0cf344a00b">ChangeStatus</a> gtirb::ByteInterval::addBlock </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> *&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a> to be a part of this interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to move the block to. </td></tr>
    <tr><td class="paramname">N</td><td>The block to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ChangeStatus indicating whether the insertion took place (<code>Accepted</code>), was unnecessary because this node already contained the <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a> (<code>NoChange</code>), or could not be completed (<code>Rejected</code>). </dd></dl>

</div>
</div>
<a id="a75d01fa068e0484d58f374d2c128d0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d01fa068e0484d58f374d2c128d0f2">&#9670;&nbsp;</a></span>addSymbolicExpression() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExprType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>&amp; gtirb::ByteInterval::addSymbolicExpression </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> to this interval. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExprType</td><td>The type of symbolic expression to create (<a class="el" href="structgtirb_1_1_sym_addr_const.html">SymAddrConst</a>, <a class="el" href="structgtirb_1_1_sym_addr_addr.html">SymAddrAddr</a>, etc). </td></tr>
    <tr><td class="paramname">Args</td><td>The arguments to construct something of ExprType. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>The offset to add the new <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> at. </td></tr>
    <tr><td class="paramname">A</td><td>The arguments to construct something of ExprType. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>. </dd></dl>

</div>
</div>
<a id="a74e4791188ab46a92d1242f337eba656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e4791188ab46a92d1242f337eba656">&#9670;&nbsp;</a></span>addSymbolicExpression() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>&amp; gtirb::ByteInterval::addSymbolicExpression </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>SymExpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> to this interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to add the new <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> at. </td></tr>
    <tr><td class="paramname">SymExpr</td><td>An existing <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> to copy into this interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>. </dd></dl>

</div>
</div>
<a id="a94b3279ea359b70e1bd83e3936e41e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b3279ea359b70e1bd83e3936e41e65">&#9670;&nbsp;</a></span>blocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a> gtirb::ByteInterval::blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a range of the Block objects in this interval. </p>

</div>
</div>
<a id="a1fc87b6ac73b67d6cc19936e24b991ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc87b6ac73b67d6cc19936e24b991ef">&#9670;&nbsp;</a></span>blocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a> gtirb::ByteInterval::blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const range of the Block objects in this interval. </p>

</div>
</div>
<a id="a80e8ea8f850238b35f0f2c919537c9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e8ea8f850238b35f0f2c919537c9f8">&#9670;&nbsp;</a></span>blocks_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a906497ecbe80ec11c48115066609face">block_iterator</a> gtirb::ByteInterval::blocks_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first Block. </p>

</div>
</div>
<a id="af1ffba5b7f527ad10399e46b26edbc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ffba5b7f527ad10399e46b26edbc0a">&#9670;&nbsp;</a></span>blocks_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aeb7a62cf27007ec7f00120e86d11273e">const_block_iterator</a> gtirb::ByteInterval::blocks_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the first Block. </p>

</div>
</div>
<a id="aa64ba0ca13df34c709da7ffe9c6f88ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64ba0ca13df34c709da7ffe9c6f88ab">&#9670;&nbsp;</a></span>blocks_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a906497ecbe80ec11c48115066609face">block_iterator</a> gtirb::ByteInterval::blocks_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the element following the last Block. </p>

</div>
</div>
<a id="aa2d2fafc0d043da8b7af8afd14c2c546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d2fafc0d043da8b7af8afd14c2c546">&#9670;&nbsp;</a></span>blocks_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aeb7a62cf27007ec7f00120e86d11273e">const_block_iterator</a> gtirb::ByteInterval::blocks_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the element following the last Block. </p>

</div>
</div>
<a id="a307c16d10cb2fa7225c2673926c2d8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307c16d10cb2fa7225c2673926c2d8d5">&#9670;&nbsp;</a></span>bytes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">bytes_range</a>&lt;T&gt; gtirb::ByteInterval::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of data in this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a303ad2e729e34747f4c5ce3d36c54a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303ad2e729e34747f4c5ce3d36c54a50">&#9670;&nbsp;</a></span>bytes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">const_bytes_range</a>&lt;T&gt; gtirb::ByteInterval::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of data in this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a9787dd32694232dd6f6803c07da6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9787dd32694232dd6f6803c07da6f0">&#9670;&nbsp;</a></span>bytes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">bytes_range</a>&lt;T&gt; gtirb::ByteInterval::bytes </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of data in this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the vector. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4978ed9a080ed359d2e59fc5cc3eb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4978ed9a080ed359d2e59fc5cc3eb4e">&#9670;&nbsp;</a></span>bytes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">const_bytes_range</a>&lt;T&gt; gtirb::ByteInterval::bytes </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of data in this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the vector. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86f99034eff9124ad9227658313e0adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f99034eff9124ad9227658313e0adf">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::bytes_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning of this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86ed5f5390c78d33be9ab94e0423f9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ed5f5390c78d33be9ab94e0423f9f3">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::bytes_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning of this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68ff5e74bd9a5908e4c383dac046cd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ff5e74bd9a5908e4c383dac046cd56">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::bytes_begin </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning of this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the vector. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7c1b2f7f97048547d5daabdcd1ef551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c1b2f7f97048547d5daabdcd1ef551">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::bytes_begin </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning of this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the vector. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3bf693f878f160fb775043b57fb6c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bf693f878f160fb775043b57fb6c9c">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::bytes_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the end of this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a626a0758bc7fb99836eefcdc26e299c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626a0758bc7fb99836eefcdc26e299c8">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::bytes_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the end of this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfbfbe9829a17f14e54410ac613230e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbfbe9829a17f14e54410ac613230e3">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::bytes_end </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the end of this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the vector. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad71737db3829444e128b677da15b8774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71737db3829444e128b677da15b8774">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::bytes_end </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the end of this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the vector. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec8ef982b7b2b4862e3fe569de719832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8ef982b7b2b4862e3fe569de719832">&#9670;&nbsp;</a></span>code_blocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a> gtirb::ByteInterval::code_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a range of the <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects in this interval. </p>

</div>
</div>
<a id="aa1770e97b003da509e318ee34f728fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1770e97b003da509e318ee34f728fe9">&#9670;&nbsp;</a></span>code_blocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a> gtirb::ByteInterval::code_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const range of the <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects in this interval. </p>

</div>
</div>
<a id="ab43599abd3770fd1a9ed358c46cefb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43599abd3770fd1a9ed358c46cefb93">&#9670;&nbsp;</a></span>code_blocks_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a5616996099d2349bf3808b69f35e0267">code_block_iterator</a> gtirb::ByteInterval::code_blocks_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </p>

</div>
</div>
<a id="af68a85fda320a4605d21af05cef200c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68a85fda320a4605d21af05cef200c7">&#9670;&nbsp;</a></span>code_blocks_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a41e6b824d4be6f520ad00d485ea1540c">const_code_block_iterator</a> gtirb::ByteInterval::code_blocks_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the first <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </p>

</div>
</div>
<a id="a6f35d331b2c4cd8873ee3eeaf2fb2d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f35d331b2c4cd8873ee3eeaf2fb2d29">&#9670;&nbsp;</a></span>code_blocks_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a5616996099d2349bf3808b69f35e0267">code_block_iterator</a> gtirb::ByteInterval::code_blocks_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the element following the last <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </p>

</div>
</div>
<a id="a57d7f6f0b9c401e3cce9f4857bd26c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d7f6f0b9c401e3cce9f4857bd26c3d">&#9670;&nbsp;</a></span>code_blocks_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a41e6b824d4be6f520ad00d485ea1540c">const_code_block_iterator</a> gtirb::ByteInterval::code_blocks_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the element following the last <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a>. </p>

</div>
</div>
<a id="a18925fb9dca97989ae51261de981deed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18925fb9dca97989ae51261de981deed">&#9670;&nbsp;</a></span>Create() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>* gtirb::ByteInterval::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an unitialized <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html" title="The context under which GTIRB operations occur.">Context</a> in which this <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> will be held. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a>. </dd></dl>

</div>
</div>
<a id="a6b13dd0f8c68c067676701fe16f6b37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b13dd0f8c68c067676701fe16f6b37f">&#9670;&nbsp;</a></span>Create() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>* gtirb::ByteInterval::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>Size</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>InitSize</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>An input iterator yielding bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html">Context</a> in which this interval will be held. </td></tr>
    <tr><td class="paramname">BytesBegin</td><td>The start of the range to copy to the byte vector. </td></tr>
    <tr><td class="paramname">BytesEnd</td><td>The end of the range to copy to the byte vector. </td></tr>
    <tr><td class="paramname">Size</td><td>The size of this interval in bytes. Defaults to the size of the range of bytes. If specified, either trucates the range of bytes given or pads it at the end with zeroes. </td></tr>
    <tr><td class="paramname">InitSize</td><td>The number of bytes with initialized values. Defaults to the size of the range of bytes. If specified, does NOT zero out values from the range past this number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a>. </dd></dl>

</div>
</div>
<a id="a5b712e0c5309786aff95f5e090be9653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b712e0c5309786aff95f5e090be9653">&#9670;&nbsp;</a></span>Create() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>* gtirb::ByteInterval::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classgtirb_1_1_addr.html">Addr</a> &gt;&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>Size</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>InitSize</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>An input iterator yielding bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html">Context</a> in which this interval will be held. </td></tr>
    <tr><td class="paramname">Address</td><td>An (optional) fixed address for this interval. </td></tr>
    <tr><td class="paramname">BytesBegin</td><td>The start of the range to copy to the byte vector. </td></tr>
    <tr><td class="paramname">BytesEnd</td><td>The end of the range to copy to the byte vector. </td></tr>
    <tr><td class="paramname">Size</td><td>The size of this interval in bytes. Defaults to the size of the range of bytes. If specified, either trucates the range of bytes given or pads it at the end with zeroes. </td></tr>
    <tr><td class="paramname">InitSize</td><td>The number of bytes with initialized values. Defaults to the size of the range of bytes. If specified, does NOT zero out values from the range past this number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a>. </dd></dl>

</div>
</div>
<a id="a493bc75db2c0543f6bf8d814e73a90d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493bc75db2c0543f6bf8d814e73a90d1">&#9670;&nbsp;</a></span>Create() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>* gtirb::ByteInterval::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classgtirb_1_1_addr.html">Addr</a> &gt;&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>InitSize</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html">Context</a> in which this interval will be held. </td></tr>
    <tr><td class="paramname">Address</td><td>An (optional) fixed address for this interval. </td></tr>
    <tr><td class="paramname">Size</td><td>The size of this interval in bytes. </td></tr>
    <tr><td class="paramname">InitSize</td><td>The number of bytes with initialized values. Defaults to the value of Size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a>. </dd></dl>

</div>
</div>
<a id="acb982ae948d600730d4837f50c3ea1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb982ae948d600730d4837f50c3ea1ce">&#9670;&nbsp;</a></span>Create() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>* gtirb::ByteInterval::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>InitSize</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html">Context</a> in which this interval will be held. </td></tr>
    <tr><td class="paramname">Size</td><td>The size of this interval in bytes. </td></tr>
    <tr><td class="paramname">InitSize</td><td>The number of bytes with initialized values. Defaults to the value of Size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_byte_interval.html" title="A contiguous region of bytes in a binary.">ByteInterval</a>. </dd></dl>

</div>
</div>
<a id="a5e0e176eab6fee402d801559330d3df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0e176eab6fee402d801559330d3df4">&#9670;&nbsp;</a></span>data_blocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a> gtirb::ByteInterval::data_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a range of the <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects in this interval. </p>

</div>
</div>
<a id="a5ae099f21a30a0e41b749082675d5c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae099f21a30a0e41b749082675d5c55">&#9670;&nbsp;</a></span>data_blocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a> gtirb::ByteInterval::data_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const range of the <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects in this interval. </p>

</div>
</div>
<a id="addd4f769883a604cc16958307ed17504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd4f769883a604cc16958307ed17504">&#9670;&nbsp;</a></span>data_blocks_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#acba13200137a60aa6d6bfd93eaa6dd89">data_block_iterator</a> gtirb::ByteInterval::data_blocks_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>. </p>

</div>
</div>
<a id="a72c0cfb7690cecaf8bb03c4e3ac0d6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c0cfb7690cecaf8bb03c4e3ac0d6e2">&#9670;&nbsp;</a></span>data_blocks_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aba6ec5081f685d60287e0eb89cf24818">const_data_block_iterator</a> gtirb::ByteInterval::data_blocks_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the first <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>. </p>

</div>
</div>
<a id="a327f6b285d6d06940dcb7599279f346d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327f6b285d6d06940dcb7599279f346d">&#9670;&nbsp;</a></span>data_blocks_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#acba13200137a60aa6d6bfd93eaa6dd89">data_block_iterator</a> gtirb::ByteInterval::data_blocks_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the element following the last <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>. </p>

</div>
</div>
<a id="a3890092f828eee175043c62d4a41062e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3890092f828eee175043c62d4a41062e">&#9670;&nbsp;</a></span>data_blocks_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aba6ec5081f685d60287e0eb89cf24818">const_data_block_iterator</a> gtirb::ByteInterval::data_blocks_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the element following the last <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>. </p>

</div>
</div>
<a id="a0e87c4f2dc45ad83c3a035fb035585bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e87c4f2dc45ad83c3a035fb035585bb">&#9670;&nbsp;</a></span>eraseBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::eraseBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>End</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase data from this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data you wish to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Begin</td><td>The start of the data to erase. </td></tr>
    <tr><td class="paramname">End</td><td>The end of the data to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element after those erased by this call. </dd></dl>

</div>
</div>
<a id="a927a15b9dafee400206f1d01dee07a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927a15b9dafee400206f1d01dee07a14">&#9670;&nbsp;</a></span>findBlocksAt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a> gtirb::ByteInterval::findBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that start at an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that are at the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="aa8a27f065f253545f41f434e04ddb781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a27f065f253545f41f434e04ddb781">&#9670;&nbsp;</a></span>findBlocksAt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a> gtirb::ByteInterval::findBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that start at an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that are at the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="a59878361318429a61e82bc5aa5e91b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59878361318429a61e82bc5aa5e91b5f">&#9670;&nbsp;</a></span>findBlocksAt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a> gtirb::ByteInterval::findBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that start between a range of addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low address, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high address, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that are between the addresses. </dd></dl>

</div>
</div>
<a id="acec2f6e42a78aa0150c7cd74159116da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec2f6e42a78aa0150c7cd74159116da">&#9670;&nbsp;</a></span>findBlocksAt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a> gtirb::ByteInterval::findBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that start between a range of addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low address, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high address, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that are between the addresses. </dd></dl>

</div>
</div>
<a id="acb451c5147d8d9132dce1b4f6578b188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb451c5147d8d9132dce1b4f6578b188">&#9670;&nbsp;</a></span>findBlocksAtOffset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a> gtirb::ByteInterval::findBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that start between a range of offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low offset, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high offset, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that are between the offsets. </dd></dl>

</div>
</div>
<a id="aaf080a5162e79341ed299bade7081faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf080a5162e79341ed299bade7081faf">&#9670;&nbsp;</a></span>findBlocksAtOffset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a> gtirb::ByteInterval::findBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that start between a range of offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low offset, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high offset, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that are between the offsets. </dd></dl>

</div>
</div>
<a id="aa6b9f490245e66078317ebd5ab6d3270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b9f490245e66078317ebd5ab6d3270">&#9670;&nbsp;</a></span>findBlocksAtOffset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a47b9128195d9da23d68d66669049bdf1">block_range</a> gtirb::ByteInterval::findBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that start at an offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that are at the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="aed158ed4cead61409934c2a685cfad77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed158ed4cead61409934c2a685cfad77">&#9670;&nbsp;</a></span>findBlocksAtOffset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aecb2273d4049f8e88ee1901e80e872f8">const_block_range</a> gtirb::ByteInterval::findBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that start at an offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that are at the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="aab7227044a2a59cc232907d390a4db28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7227044a2a59cc232907d390a4db28">&#9670;&nbsp;</a></span>findBlocksOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a99b01abb4d4050e12ac762d248d1f5a1">block_subrange</a> gtirb::ByteInterval::findBlocksOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that have bytes that lie within the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that intersect the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="a35061b7611c01ccbaf45a1cb88867d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35061b7611c01ccbaf45a1cb88867d47">&#9670;&nbsp;</a></span>findBlocksOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a0ce195b80ff3bccce7f426c985a49014">const_block_subrange</a> gtirb::ByteInterval::findBlocksOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that have bytes that lie within the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that intersect the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="aab3ba4b9b92fbcc2aa9185c8954c6c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3ba4b9b92fbcc2aa9185c8954c6c8f">&#9670;&nbsp;</a></span>findBlocksOnOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a99b01abb4d4050e12ac762d248d1f5a1">block_subrange</a> gtirb::ByteInterval::findBlocksOnOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that have a byte at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that contain the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="a2281c4ea48641041871680d4f05ac852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2281c4ea48641041871680d4f05ac852">&#9670;&nbsp;</a></span>findBlocksOnOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a0ce195b80ff3bccce7f426c985a49014">const_block_subrange</a> gtirb::ByteInterval::findBlocksOnOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the blocks that have a byte at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_node.html">Node</a> objects, which are either <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> or <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that contain the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="ac2063ad11170d5a858694b3212e549ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2063ad11170d5a858694b3212e549ca">&#9670;&nbsp;</a></span>findCodeBlocksAt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a> gtirb::ByteInterval::findCodeBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that start at an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that are at the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="aefd8a6071e823b89f00dfcf345468f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd8a6071e823b89f00dfcf345468f49">&#9670;&nbsp;</a></span>findCodeBlocksAt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a> gtirb::ByteInterval::findCodeBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that start at an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that are at the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="a0821f0d9cfbb0e5fbe778edf876749f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0821f0d9cfbb0e5fbe778edf876749f6">&#9670;&nbsp;</a></span>findCodeBlocksAt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a> gtirb::ByteInterval::findCodeBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that start between a range of addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low address, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high address, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that are between the addresses. </dd></dl>

</div>
</div>
<a id="ae8a17470cf973d93c9b1d5ece82044c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a17470cf973d93c9b1d5ece82044c5">&#9670;&nbsp;</a></span>findCodeBlocksAt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a> gtirb::ByteInterval::findCodeBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that start between a range of addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low address, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high address, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that are between the addresses. </dd></dl>

</div>
</div>
<a id="a4a02ddd217ce6b6f2afc1d7dd9c0cfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a02ddd217ce6b6f2afc1d7dd9c0cfca">&#9670;&nbsp;</a></span>findCodeBlocksAtOffset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a> gtirb::ByteInterval::findCodeBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that start between a range of offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low offset, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high offset, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that are between the offsets. </dd></dl>

</div>
</div>
<a id="a491a05604112f3662900f571f5af5823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491a05604112f3662900f571f5af5823">&#9670;&nbsp;</a></span>findCodeBlocksAtOffset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a> gtirb::ByteInterval::findCodeBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that start between a range of offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low offset, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high offset, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that are between the offsets. </dd></dl>

</div>
</div>
<a id="a74604030ae0e750e3d7c3db567cd3c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74604030ae0e750e3d7c3db567cd3c6e">&#9670;&nbsp;</a></span>findCodeBlocksAtOffset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#aade3e2c337788ff115b5547c795ea9c9">code_block_range</a> gtirb::ByteInterval::findCodeBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that start at an offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that are at the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="a9c8eb24a288635ba4bb5ff132b00e4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8eb24a288635ba4bb5ff132b00e4c3">&#9670;&nbsp;</a></span>findCodeBlocksAtOffset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a66cf4ad54f003fc78102cca1ddb85b18">const_code_block_range</a> gtirb::ByteInterval::findCodeBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that start at an offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that are at the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="a889be6b137f1816d4736f0e88c23f0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889be6b137f1816d4736f0e88c23f0d1">&#9670;&nbsp;</a></span>findCodeBlocksOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a81e2f48c16615b2f9c2c84daaa3c3cda">code_block_subrange</a> gtirb::ByteInterval::findCodeBlocksOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that have bytes that lie within the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that intersect the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="a479700aec6dd6e079d946676ce5abf1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479700aec6dd6e079d946676ce5abf1c">&#9670;&nbsp;</a></span>findCodeBlocksOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a65a2c7a6e0289bb8c81506131f4c2dc6">const_code_block_subrange</a> gtirb::ByteInterval::findCodeBlocksOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that have bytes that lie within the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects that intersect the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="ac07b10efdd925c4a6581c6e86c8b8215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07b10efdd925c4a6581c6e86c8b8215">&#9670;&nbsp;</a></span>findCodeBlocksOnOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a81e2f48c16615b2f9c2c84daaa3c3cda">code_block_subrange</a> gtirb::ByteInterval::findCodeBlocksOnOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that have a byte at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that contain the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="a06021a8ceb808795c299d6ba74b94735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06021a8ceb808795c299d6ba74b94735">&#9670;&nbsp;</a></span>findCodeBlocksOnOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a65a2c7a6e0289bb8c81506131f4c2dc6">const_code_block_subrange</a> gtirb::ByteInterval::findCodeBlocksOnOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the code blocks that have a byte at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> objects, that contain the addres <code>Off</code>. </dd></dl>

</div>
</div>
<a id="a63dc5363c2d4ff56d14bfd48d751162f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dc5363c2d4ff56d14bfd48d751162f">&#9670;&nbsp;</a></span>findDataBlocksAt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a> gtirb::ByteInterval::findDataBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that start at an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that are at the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="a92f0086f28d68784d3896eb1709489c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f0086f28d68784d3896eb1709489c0">&#9670;&nbsp;</a></span>findDataBlocksAt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a> gtirb::ByteInterval::findDataBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that start at an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that are at the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="ac9d73a66820013d9d172acbb5af82469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d73a66820013d9d172acbb5af82469">&#9670;&nbsp;</a></span>findDataBlocksAt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a> gtirb::ByteInterval::findDataBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that start between a range of addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low address, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high address, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that are between the addresses. </dd></dl>

</div>
</div>
<a id="ad44153cf66e388941852db0525b6953b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44153cf66e388941852db0525b6953b">&#9670;&nbsp;</a></span>findDataBlocksAt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a> gtirb::ByteInterval::findDataBlocksAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that start between a range of addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low address, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high address, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that are between the addresses. </dd></dl>

</div>
</div>
<a id="a8968d98157d5273533b427407051c2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8968d98157d5273533b427407051c2e2">&#9670;&nbsp;</a></span>findDataBlocksAtOffset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a> gtirb::ByteInterval::findDataBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that start between a range of offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low offset, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high offset, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that are between the offsets. </dd></dl>

</div>
</div>
<a id="a3bb4098b3ec6298f73db58f251040428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb4098b3ec6298f73db58f251040428">&#9670;&nbsp;</a></span>findDataBlocksAtOffset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a> gtirb::ByteInterval::findDataBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that start between a range of offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low offset, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high offset, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that are between the offsets. </dd></dl>

</div>
</div>
<a id="a2ca945b537a6e75014baa75d6f8c417b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca945b537a6e75014baa75d6f8c417b">&#9670;&nbsp;</a></span>findDataBlocksAtOffset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a02fb519c7a9522d6e0f581dd5483dfbf">data_block_range</a> gtirb::ByteInterval::findDataBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that start at an offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that are at the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="a4d51e7fdb6cc98c70875e2191ebf5284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d51e7fdb6cc98c70875e2191ebf5284">&#9670;&nbsp;</a></span>findDataBlocksAtOffset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a6246849157b58c6860bf2aeb6702ac02">const_data_block_range</a> gtirb::ByteInterval::findDataBlocksAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that start at an offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that are at the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="a0a3da87af28426df76b47d0fee4f5c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3da87af28426df76b47d0fee4f5c8f">&#9670;&nbsp;</a></span>findDataBlocksOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a306f0089a518e8c7f70125f8ffd5bf8e">data_block_subrange</a> gtirb::ByteInterval::findDataBlocksOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that have bytes that lie within the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that intersect the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="ad061d5a26337ca9def02b80a75b0cf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad061d5a26337ca9def02b80a75b0cf9e">&#9670;&nbsp;</a></span>findDataBlocksOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a07919c9f159f58b568f68bc59b61d43f">const_data_block_subrange</a> gtirb::ByteInterval::findDataBlocksOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that have bytes that lie within the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects that intersect the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="a58fee010ddd4b746c158b4fd99b435de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fee010ddd4b746c158b4fd99b435de">&#9670;&nbsp;</a></span>findDataBlocksOnOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a306f0089a518e8c7f70125f8ffd5bf8e">data_block_subrange</a> gtirb::ByteInterval::findDataBlocksOnOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that have a byte at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects, that contain the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="a9f9d4b8d5b22df7c62214f4adb7aae05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9d4b8d5b22df7c62214f4adb7aae05">&#9670;&nbsp;</a></span>findDataBlocksOnOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a07919c9f159f58b568f68bc59b61d43f">const_data_block_subrange</a> gtirb::ByteInterval::findDataBlocksOnOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the data blocks that have a byte at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> objects, that contain the addres <code>Off</code>. </dd></dl>

</div>
</div>
<a id="ac00d181320247c9f1db803132bb898b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00d181320247c9f1db803132bb898b5">&#9670;&nbsp;</a></span>findSymbolicExpressionsAt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a> gtirb::ByteInterval::findSymbolicExpressionsAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the symbolic expressions that start at an address. </p>
<p>Note that only one symbolic expression can be at any given offset, so this iterator will only ever return 0 or 1 elements. This function is provided for consistency with other <a class="el" href="classgtirb_1_1_node.html">Node</a> objects; prefer <a class="el" href="classgtirb_1_1_byte_interval.html#a4b2095ccd582e266d431cca99e624825">getSymbolicExpression</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects that are at the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="ae58bdb347d2b47963d58a291a90b61c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58bdb347d2b47963d58a291a90b61c1">&#9670;&nbsp;</a></span>findSymbolicExpressionsAt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a> gtirb::ByteInterval::findSymbolicExpressionsAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the symbolic expressions that start at an address. </p>
<p>Note that only one symbolic expression can be at any given offset, so this iterator will only ever return 0 or 1 elements. This function is provided for consistency with other <a class="el" href="classgtirb_1_1_node.html">Node</a> objects; prefer <a class="el" href="classgtirb_1_1_byte_interval.html#a4b2095ccd582e266d431cca99e624825">getSymbolicExpression</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects that are at the address <code>A</code>. </dd></dl>

</div>
</div>
<a id="ae4e5ed8ca050ba674c8c9b53fd98df5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e5ed8ca050ba674c8c9b53fd98df5c">&#9670;&nbsp;</a></span>findSymbolicExpressionsAt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a> gtirb::ByteInterval::findSymbolicExpressionsAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the symbolic expressions that start between a range of addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low address, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high address, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects that are between the addresses. </dd></dl>

</div>
</div>
<a id="a4a1f7069dca14305e44507d525a296a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1f7069dca14305e44507d525a296a3">&#9670;&nbsp;</a></span>findSymbolicExpressionsAt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a> gtirb::ByteInterval::findSymbolicExpressionsAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the symbolic expressions that start between a range of addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low address, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high address, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects that are between the addresses. </dd></dl>

</div>
</div>
<a id="a9cd437910da74b362192d61adade479a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd437910da74b362192d61adade479a">&#9670;&nbsp;</a></span>findSymbolicExpressionsAtOffset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a> gtirb::ByteInterval::findSymbolicExpressionsAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the symbolic expressions that start between a range of offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low offset, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high offset, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects that are between the offsets. </dd></dl>

</div>
</div>
<a id="aec55cc1af43b9f343665e0c084ade13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec55cc1af43b9f343665e0c084ade13c">&#9670;&nbsp;</a></span>findSymbolicExpressionsAtOffset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a> gtirb::ByteInterval::findSymbolicExpressionsAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>High</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the symbolic expressions that start between a range of offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The low offset, inclusive. </td></tr>
    <tr><td class="paramname">High</td><td>The high offset, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects that are between the offsets. </dd></dl>

</div>
</div>
<a id="a9d70e6e2067b51a1e443b9dd0c95c913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d70e6e2067b51a1e443b9dd0c95c913">&#9670;&nbsp;</a></span>findSymbolicExpressionsAtOffset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a> gtirb::ByteInterval::findSymbolicExpressionsAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the symbolic expressions that start at an offset. </p>
<p>Note that only one symbolic expression can be at any given offset, so this iterator will only ever return 0 or 1 elements. This function is provided for consistency with other <a class="el" href="classgtirb_1_1_node.html">Node</a> objects; prefer <a class="el" href="classgtirb_1_1_byte_interval.html#a4b2095ccd582e266d431cca99e624825">getSymbolicExpression</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects that are at the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="a3abcdd7487176ad98e17d7d956e1a06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abcdd7487176ad98e17d7d956e1a06e">&#9670;&nbsp;</a></span>findSymbolicExpressionsAtOffset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a> gtirb::ByteInterval::findSymbolicExpressionsAtOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the symbolic expressions that start at an offset. </p>
<p>Note that only one symbolic expression can be at any given offset, so this iterator will only ever return 0 or 1 elements. This function is provided for consistency with other <a class="el" href="classgtirb_1_1_node.html">Node</a> objects; prefer <a class="el" href="classgtirb_1_1_byte_interval.html#a4b2095ccd582e266d431cca99e624825">getSymbolicExpression</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects that are at the offset <code>Off</code>. </dd></dl>

</div>
</div>
<a id="aaf13ececea7d2b943402feeb4f1aae35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf13ececea7d2b943402feeb4f1aae35">&#9670;&nbsp;</a></span>getAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classgtirb_1_1_addr.html">Addr</a>&gt; gtirb::ByteInterval::getAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the fixed address of this interval, if present. </p>
<p>If this field is present, it may indicate the original address at which this interval was located at in memory, or it may indicate that this block's address is fixed and must not be changed. If this field is not present, it indicates that the interval is free to be moved around in memory while preserving program semantics. </p>

</div>
</div>
<a id="a573a5fcaa3a8feeb108cb42f3d5b0c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573a5fcaa3a8feeb108cb42f3d5b0c18">&#9670;&nbsp;</a></span>getBoostEndianOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::endian::order gtirb::ByteInterval::getBoostEndianOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <code>boost::endian::order</code> of this module, suitable for passing to the <code>bytes</code> iterator. </p>

</div>
</div>
<a id="a9c073ce08ee11ac7a435f155239eeaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c073ce08ee11ac7a435f155239eeaf2">&#9670;&nbsp;</a></span>getInitializedSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gtirb::ByteInterval::getInitializedSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of initialized bytes in this interval. </p>
<p>Not all bytes in this interval may correspond to bytes physically stored in the underlying file format. This can occur, for example, in BSS sections, which are zero-initialized at loadtime, but these zeroes are not stored in the file itself. If this number is smaller than the value returned by <a class="el" href="classgtirb_1_1_byte_interval.html#a403c7f5605adeef32d12573a830b9dc5">getSize</a>, this indicates that any bytes past this number are unitialized bytes with values determined at loadtime. As such, all bytes past this number in this interval's byte vector are truncated when saving to file.</p>
<p>This number will never be larger than the value returned by <a class="el" href="classgtirb_1_1_byte_interval.html#a403c7f5605adeef32d12573a830b9dc5">getSize</a>. </p>

</div>
</div>
<a id="a050df8ed14b0cbd338db6b4b1cb10b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050df8ed14b0cbd338db6b4b1cb10b59">&#9670;&nbsp;</a></span>getSection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_section.html">Section</a>* gtirb::ByteInterval::getSection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classgtirb_1_1_section.html">Section</a> this byte interval belongs to. </p>

</div>
</div>
<a id="aa9d449b4c06fd818a5def623c758d716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d449b4c06fd818a5def623c758d716">&#9670;&nbsp;</a></span>getSection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgtirb_1_1_section.html">Section</a>* gtirb::ByteInterval::getSection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classgtirb_1_1_section.html">Section</a> this byte interval belongs to. </p>

</div>
</div>
<a id="a403c7f5605adeef32d12573a830b9dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403c7f5605adeef32d12573a830b9dc5">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gtirb::ByteInterval::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of this interval in bytes. </p>
<p>If this number is greater than the value returned by <a class="el" href="classgtirb_1_1_byte_interval.html#a9c073ce08ee11ac7a435f155239eeaf2">getInitializedSize</a>, this indicates that the high addresses taken up by this interval consist of uninitialized bytes. This often occurs in BSS sections, where data is zero-initialized rather than stored as zeroes in the binary. </p>

</div>
</div>
<a id="a4b2095ccd582e266d431cca99e624825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2095ccd582e266d431cca99e624825">&#9670;&nbsp;</a></span>getSymbolicExpression() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>* gtirb::ByteInterval::getSymbolicExpression </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the symbolic expression at the given offset, if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset of the <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> at that offset, or nullptr if there is no <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> at that offset. </dd></dl>

</div>
</div>
<a id="a58ac8848323b27aebe2785b5b77d8263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ac8848323b27aebe2785b5b77d8263">&#9670;&nbsp;</a></span>getSymbolicExpression() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>* gtirb::ByteInterval::getSymbolicExpression </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the symbolic expression at the given offset, if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset of the <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> at that offset, or nullptr if there is no <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> at that offset. </dd></dl>

</div>
</div>
<a id="a74d532a81776e4896f8b8604f9f8cb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d532a81776e4896f8b8604f9f8cb73">&#9670;&nbsp;</a></span>insertBytes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::insertBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a single datum into this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data you wish to insert into the byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pos</td><td>The position in the byte vector to insert data at. </td></tr>
    <tr><td class="paramname">X</td><td>The data to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element inserted by this call. </dd></dl>

</div>
</div>
<a id="ad04f93e068365bd6451a514c3235c192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04f93e068365bd6451a514c3235c192">&#9670;&nbsp;</a></span>insertBytes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::insertBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>VectorOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>ElementOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a single datum into this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data you wish to insert into the byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pos</td><td>The position in the byte vector to insert data at. </td></tr>
    <tr><td class="paramname">X</td><td>The data to insert. </td></tr>
    <tr><td class="paramname">VectorOrder</td><td>The endianness of the data in the byte vector. </td></tr>
    <tr><td class="paramname">ElementOrder</td><td>The endianness of the data to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element inserted by this call. </dd></dl>

</div>
</div>
<a id="a745a56af06de2e711ce4ebfe36fdb2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745a56af06de2e711ce4ebfe36fdb2a5">&#9670;&nbsp;</a></span>insertBytes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::insertBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>End</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data you wish to insert into the byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
    <tr><td class="paramname">InputIterator</td><td>The type of an iterator yielding T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pos</td><td>The position in the byte vector to insert data at. </td></tr>
    <tr><td class="paramname">Begin</td><td>The start of the data to insert. </td></tr>
    <tr><td class="paramname">End</td><td>The end of the data to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element inserted by this call. </dd></dl>

</div>
</div>
<a id="aff09ea69677f7139527ed42969156090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff09ea69677f7139527ed42969156090">&#9670;&nbsp;</a></span>insertBytes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt;T&gt; gtirb::ByteInterval::insertBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">const_bytes_iterator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>VectorOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>ElementsOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into this byte vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data you wish to insert into the byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
    <tr><td class="paramname">InputIterator</td><td>The type of an iterator yielding T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pos</td><td>The position in the byte vector to insert data at. </td></tr>
    <tr><td class="paramname">Begin</td><td>The start of the data to insert. </td></tr>
    <tr><td class="paramname">End</td><td>The end of the data to insert. </td></tr>
    <tr><td class="paramname">VectorOrder</td><td>The endianness of the data in the byte vector. </td></tr>
    <tr><td class="paramname">ElementsOrder</td><td>The endianness of the data to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element inserted by this call. </dd></dl>

</div>
</div>
<a id="af6b6ab4f1b6e48498eab46ff2ea7f146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b6ab4f1b6e48498eab46ff2ea7f146">&#9670;&nbsp;</a></span>rawBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* gtirb::ByteInterval::rawBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the raw data underlying this byte vector. </p>
<p>Much like std::vector::data, this function is low-level and potentially unsafe. This pointer refers to valid memory only where an iterator would be valid to point to. Modifying the size of the byte vector may invalidate this pointer. Any endian conversions will not be performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ec7c816f4d210543007964ba1d69050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec7c816f4d210543007964ba1d69050">&#9670;&nbsp;</a></span>rawBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* gtirb::ByteInterval::rawBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the raw data underlying this byte vector. </p>
<p>Much like std::vector::data, this function is low-level and potentially unsafe. This pointer refers to valid memory only where an iterator would be valid to point to. Modifying the size of the byte vector may invalidate this pointer. Any endian conversions will not be performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this byte vector. Must be a POD type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeac76766e70c9e455d8c2e740fc5d4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac76766e70c9e455d8c2e740fc5d4a8">&#9670;&nbsp;</a></span>removeBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegtirb.html#ad7db2026ea49abab0562fd0cf344a00b">ChangeStatus</a> gtirb::ByteInterval::removeBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a> *&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a block from this interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>The block to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the operation succeeded. This operation can fail if the node to remove is not actually part of this node to begin with. </dd></dl>

</div>
</div>
<a id="ace1f05a18d729d1febd5acd410c3c2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1f05a18d729d1febd5acd410c3c2ff">&#9670;&nbsp;</a></span>removeBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegtirb.html#ad7db2026ea49abab0562fd0cf344a00b">ChangeStatus</a> gtirb::ByteInterval::removeBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> *&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a block from this interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>The block to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the operation succeeded. This operation can fail if the node to remove is not actually part of this node to begin with. </dd></dl>

</div>
</div>
<a id="afc2d53d3934c8dd5c6db3869ed625c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2d53d3934c8dd5c6db3869ed625c64">&#9670;&nbsp;</a></span>removeSymbolicExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gtirb::ByteInterval::removeSymbolicExpression </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> at the given offset, if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Off</td><td>The offset of the <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the operation succeeded. This operation can fail if the node to remove is not actually part of this node to begin with. </dd></dl>

</div>
</div>
<a id="a06a2a39cab63acb536e44eb36ffd5278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a2a39cab63acb536e44eb36ffd5278">&#9670;&nbsp;</a></span>setAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gtirb::ByteInterval::setAddress </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classgtirb_1_1_addr.html">Addr</a> &gt;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or clear the address of this interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Either the new address, or an empty std::optional if you wish to remove the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9468f6913c9aa8c64cfcd91e3d455005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9468f6913c9aa8c64cfcd91e3d455005">&#9670;&nbsp;</a></span>setInitializedSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtirb::ByteInterval::setInitializedSize </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of initialized bytes in this interval. </p>
<p>Not all bytes in this interval may correspond to bytes physically stored in the underlying file format. This can occur, for example, in BSS sections, which are zero-initialized at loadtime, but these zeroes are not stored in the file itself. If this number is smaller than the value returned by <a class="el" href="classgtirb_1_1_byte_interval.html#a403c7f5605adeef32d12573a830b9dc5">getSize</a>, this indicates that any bytes past this number are unitialized bytes with values determined at loadtime. As such, all bytes past this number in this interval's byte vector are truncated when saving to file.</p>
<p>If the number specified is larger than <a class="el" href="classgtirb_1_1_byte_interval.html#a403c7f5605adeef32d12573a830b9dc5">getSize</a>, then the byte vector is expanded with zeroes to be equal to the new allocated size. </p>

</div>
</div>
<a id="a40baa1fdcd468fd8f6f52f2eb1cce565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40baa1fdcd468fd8f6f52f2eb1cce565">&#9670;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gtirb::ByteInterval::setSize </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the size of this interval. </p>
<p>This will also adjust <a class="el" href="classgtirb_1_1_byte_interval.html#a9c073ce08ee11ac7a435f155239eeaf2">getInitializedSize</a> if the size given is less than the initialized size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The new size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57bc61b0a1617d464b00aaab1a794cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bc61b0a1617d464b00aaab1a794cd2">&#9670;&nbsp;</a></span>symbolic_expressions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#afd12ca596011ad35839c267401d4e588">symbolic_expression_range</a> gtirb::ByteInterval::symbolic_expressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a range of the <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects in this interval. </p>

</div>
</div>
<a id="acb7fd35f3ba13474403cbf15baa6b45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7fd35f3ba13474403cbf15baa6b45d">&#9670;&nbsp;</a></span>symbolic_expressions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#a44d187d303d730cbb3fda3621293b9c0">const_symbolic_expression_range</a> gtirb::ByteInterval::symbolic_expressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const range of the <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a> objects in this interval. </p>

</div>
</div>
<a id="a1c4e81c32e735376131fc878366b1de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4e81c32e735376131fc878366b1de9">&#9670;&nbsp;</a></span>symbolic_expressions_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ae3e013b5817c7046b1791904debac22e">symbolic_expression_iterator</a> gtirb::ByteInterval::symbolic_expressions_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>. </p>

</div>
</div>
<a id="af0e443dae578f8da16f0f7e6ebf7f12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e443dae578f8da16f0f7e6ebf7f12b">&#9670;&nbsp;</a></span>symbolic_expressions_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ad8b707f7e9e50062a468b820d7e79f87">const_symbolic_expression_iterator</a> gtirb::ByteInterval::symbolic_expressions_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the first <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>. </p>

</div>
</div>
<a id="abb5331b945a2c31e33ce9cadb74bd4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5331b945a2c31e33ce9cadb74bd4dd">&#9670;&nbsp;</a></span>symbolic_expressions_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ae3e013b5817c7046b1791904debac22e">symbolic_expression_iterator</a> gtirb::ByteInterval::symbolic_expressions_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the element following the last <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>. </p>

</div>
</div>
<a id="a0aa5a64005b3a7e51a989ea51080aeb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa5a64005b3a7e51a989ea51080aeb6">&#9670;&nbsp;</a></span>symbolic_expressions_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html#ad8b707f7e9e50062a468b820d7e79f87">const_symbolic_expression_iterator</a> gtirb::ByteInterval::symbolic_expressions_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the element following the last <a class="el" href="group___s_y_m_b_o_l_i_c___e_x_p_r_e_s_s_i_o_n___g_r_o_u_p.html#ga76c75a30283841464ab659824167b1b8">SymbolicExpression</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a34055062091a7a77b0032d904a2844ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34055062091a7a77b0032d904a2844ad">&#9670;&nbsp;</a></span>CodeBlock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgtirb_1_1_code_block.html">CodeBlock</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac26c806e60ca4a0547680edb68f6e39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26c806e60ca4a0547680edb68f6e39b">&#9670;&nbsp;</a></span>Context</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgtirb_1_1_context.html">Context</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2aac6b337c40507a2c713bcafc41b95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aac6b337c40507a2c713bcafc41b95b">&#9670;&nbsp;</a></span>DataBlock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21f639900c480510650969df9c74d17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f639900c480510650969df9c74d17d">&#9670;&nbsp;</a></span>Module</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgtirb_1_1_module.html">Module</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bd6fc422149e1c8416770631b28d40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd6fc422149e1c8416770631b28d40c">&#9670;&nbsp;</a></span>Section</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgtirb_1_1_section.html">Section</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca7995861301f2eefb390acea47c34a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7995861301f2eefb390acea47c34a9">&#9670;&nbsp;</a></span>SerializationTestHarness</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SerializationTestHarness</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_byte_interval_8hpp_source.html">ByteInterval.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
