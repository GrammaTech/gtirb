<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GTIRB: AuxData</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GTIRB
   &#160;<span id="projectnumber">v1.10.4</span>
   </div>
   <div id="projectbrief">GrammaTech Intermediate Representation for Binaries: C++ API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AuxData</div>  </div>
</div><!--header-->
<div class="contents">

<p>AuxData objects can be attached to the <a class="el" href="classgtirb_1_1_i_r.html">IR</a> or individual Modules to store additional client-specific data in a portable way.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:_aux_data_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_aux_data_8hpp.html">AuxData.hpp</a></td></tr>
<tr class="memdesc:_aux_data_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types and operations for auxiliary data. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:_aux_data_schema_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_aux_data_schema_8hpp.html">AuxDataSchema.hpp</a></td></tr>
<tr class="memdesc:_aux_data_schema_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type schema for sanctioned AuxData types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits.html">gtirb::auxdata_traits&lt; T, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides type information and serialization functions for types which can be stored in AuxData.  <a href="structgtirb_1_1auxdata__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1is__mapping.html">gtirb::is_mapping&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class that identifies whether T is a mapping container type.  <a href="structgtirb_1_1is__mapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1is__sequence.html">gtirb::is_sequence&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class that identifies whether T is a sequential container type.  <a href="structgtirb_1_1is__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9715fdf606b21ed7c06640e4e03623b9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_x_d_a_t_a___g_r_o_u_p.html#ga9715fdf606b21ed7c06640e4e03623b9">gtirb::auxdata_traits&lt; T, Enable &gt;::fromBytes</a> (T &amp;Object, FromByteRange &amp;FBR)=delete</td></tr>
<tr class="memdesc:ga9715fdf606b21ed7c06640e4e03623b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an object from a sequence of bytes.  <a href="group___a_u_x_d_a_t_a___g_r_o_u_p.html#ga9715fdf606b21ed7c06640e4e03623b9">More...</a><br /></td></tr>
<tr class="separator:ga9715fdf606b21ed7c06640e4e03623b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f3e95e8b817966e7c88d065af9512b3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_x_d_a_t_a___g_r_o_u_p.html#ga4f3e95e8b817966e7c88d065af9512b3">gtirb::auxdata_traits&lt; T, Enable &gt;::toBytes</a> (const T &amp;Object, ToByteRange &amp;TBR)=delete</td></tr>
<tr class="memdesc:ga4f3e95e8b817966e7c88d065af9512b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an object to a sequence of bytes.  <a href="group___a_u_x_d_a_t_a___g_r_o_u_p.html#ga4f3e95e8b817966e7c88d065af9512b3">More...</a><br /></td></tr>
<tr class="separator:ga4f3e95e8b817966e7c88d065af9512b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b8b6f7b8266b1a2fe7e3ca928bb10d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_x_d_a_t_a___g_r_o_u_p.html#gae9b8b6f7b8266b1a2fe7e3ca928bb10d">gtirb::auxdata_traits&lt; T, Enable &gt;::type_name</a> ()=delete</td></tr>
<tr class="memdesc:gae9b8b6f7b8266b1a2fe7e3ca928bb10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">String representation of the serialized type of T.  <a href="group___a_u_x_d_a_t_a___g_r_o_u_p.html#gae9b8b6f7b8266b1a2fe7e3ca928bb10d">More...</a><br /></td></tr>
<tr class="separator:gae9b8b6f7b8266b1a2fe7e3ca928bb10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>AuxData objects can be attached to the <a class="el" href="classgtirb_1_1_i_r.html">IR</a> or individual Modules to store additional client-specific data in a portable way. </p>
<p>AuxData can store the following types:</p><ul>
<li>all integral types</li>
<li><a class="el" href="classgtirb_1_1_addr.html" title="A special class to store an Effective Address.">Addr</a></li>
<li><a class="el" href="structgtirb_1_1_offset.html" title="Describes a location inside a node (byte interval, block, etc).">Offset</a></li>
<li><a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a></li>
<li>sequential containers</li>
<li>mapping containers</li>
<li>std::tuple</li>
</ul>
<h3><a class="anchor" id="autotoc_md0"></a>
Supporting Additional Types</h3>
<p>Support for additional containers can be added by specializing <a class="el" href="structgtirb_1_1is__sequence.html">is_sequence</a> or <a class="el" href="structgtirb_1_1is__mapping.html">is_mapping</a>. Once serialized, the data does not depend on any specific container type, and its contents can be deserialized into different containers of the same kind (e.g. <code>std::list</code> to <code>std::vector</code>).</p>
<p>Support for other types can be added by specializing <a class="el" href="structgtirb_1_1auxdata__traits.html">auxdata_traits</a> to provide serialization functions. However, AuxData containing these types will not be accessible to other clients which are not compiled with support for those types. It is preferable to store data using the basic types whenever possible, in order to maximize interoperability.</p>
<h3><a class="anchor" id="autotoc_md1"></a>
'Sanctioned' AuxData Tables</h3>
<p>We specify a small number of standard AuxData table schemata to support interoperability. For details, see md_AuxData. C++ schemata for the sanctioned tables are present in <a class="el" href="_aux_data_schema_8hpp.html">AuxDataSchema.hpp</a>.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Adding Custom AuxData Tables</h3>
<p>Clients may add their own AuxData tables in the C++ API by defining their own schemata. Schemata should be defined by extending the <a class="el" href="namespacegtirb_1_1schema.html">gtirb::schema</a> namespace. Each schema should be a struct declaring public members for the type's name and its C++ type. One can follow the model provided by the schemata in <a class="el" href="_aux_data_schema_8hpp.html">AuxDataSchema.hpp</a>.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Serialization Format</h3>
<p>AuxData is serialized by packing the contents into a byte array, which is stored in a protobuf message along with a string which identifies the type in a portable fashion.</p>
<p>Fixed-size types such as integers, <a class="el" href="classgtirb_1_1_addr.html" title="A special class to store an Effective Address.">Addr</a>, etc are packed by swapping their bytes to little-endian order and writing them directly to the byte array. Containers first write out the number of elements (as a uint64_t), then write each element one after another. Tuples are similar but omit the size, since it can be inferred from the type. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9715fdf606b21ed7c06640e4e03623b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9715fdf606b21ed7c06640e4e03623b9">&#9670;&nbsp;</a></span>fromBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Enable  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structgtirb_1_1auxdata__traits.html">gtirb::auxdata_traits</a>&lt; T, Enable &gt;::fromBytes </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FromByteRange &amp;&#160;</td>
          <td class="paramname"><em>FBR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="_aux_data_8hpp.html">AuxData.hpp</a>&gt;</code></p>

<p>Deserialize an object from a sequence of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Object</td><td>The object to deserialize. </td></tr>
    <tr><td class="paramname">FBR</td><td>Read bytes from here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True/false dependending on if the bytes were deserialized successfully. </dd></dl>

</div>
</div>
<a id="ga4f3e95e8b817966e7c88d065af9512b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f3e95e8b817966e7c88d065af9512b3">&#9670;&nbsp;</a></span>toBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Enable  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structgtirb_1_1auxdata__traits.html">gtirb::auxdata_traits</a>&lt; T, Enable &gt;::toBytes </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ToByteRange &amp;&#160;</td>
          <td class="paramname"><em>TBR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="_aux_data_8hpp.html">AuxData.hpp</a>&gt;</code></p>

<p>Serialize an object to a sequence of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Object</td><td>The object to serialize. </td></tr>
    <tr><td class="paramname">TBR</td><td>Store byte sequence here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9b8b6f7b8266b1a2fe7e3ca928bb10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9b8b6f7b8266b1a2fe7e3ca928bb10d">&#9670;&nbsp;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Enable  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="structgtirb_1_1auxdata__traits.html">gtirb::auxdata_traits</a>&lt; T, Enable &gt;::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="_aux_data_8hpp.html">AuxData.hpp</a>&gt;</code></p>

<p>String representation of the serialized type of T. </p>
<p>This identifier is portable and independent of the specific container types. Integral types are represented with an exact size (e.g. "uint32_t"). Sequential containers are represented as "sequence&lt;...&gt;", and mapping containers are represented as "mapping&lt;...&gt;". </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
