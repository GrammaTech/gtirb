<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GTIRB: gtirb::DataBlock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GTIRB
   &#160;<span id="projectnumber">v1.10.4</span>
   </div>
   <div id="projectbrief">GrammaTech Intermediate Representation for Binaries: C++ API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegtirb.html">gtirb</a></li><li class="navelem"><a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgtirb_1_1_data_block-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gtirb::DataBlock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a data object, possibly symbolic.  
 <a href="classgtirb_1_1_data_block.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_data_block_8hpp_source.html">DataBlock.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for gtirb::DataBlock:</div>
<div class="dyncontent">
<div class="center"><img src="classgtirb_1_1_data_block__inherit__graph.png" border="0" usemap="#agtirb_1_1_data_block_inherit__map" alt="Inheritance graph"/></div>
<map name="agtirb_1_1_data_block_inherit__map" id="agtirb_1_1_data_block_inherit__map">
<area shape="rect" title="Represents a data object, possibly symbolic." alt="" coords="5,80,121,107"/>
<area shape="rect" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy." alt="" coords="20,5,107,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for gtirb::DataBlock:</div>
<div class="dyncontent">
<div class="center"><img src="classgtirb_1_1_data_block__coll__graph.png" border="0" usemap="#agtirb_1_1_data_block_coll__map" alt="Collaboration graph"/></div>
<map name="agtirb_1_1_data_block_coll__map" id="agtirb_1_1_data_block_coll__map">
<area shape="rect" title="Represents a data object, possibly symbolic." alt="" coords="5,80,121,107"/>
<area shape="rect" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy." alt="" coords="20,5,107,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad7c714363704a93c8ef04c5b8c8803d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7c714363704a93c8ef04c5b8c8803d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">bytes_iterator</a> = <a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">ByteInterval::bytes_iterator</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ad7c714363704a93c8ef04c5b8c8803d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over bytes in this block.  <a href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">More...</a><br /></td></tr>
<tr class="separator:ad7c714363704a93c8ef04c5b8c8803d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73958fc3003d630fed122786da642ee7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73958fc3003d630fed122786da642ee7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a73958fc3003d630fed122786da642ee7">bytes_range</a> = <a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">ByteInterval::bytes_range</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a73958fc3003d630fed122786da642ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range over bytes in this block.  <a href="classgtirb_1_1_data_block.html#a73958fc3003d630fed122786da642ee7">More...</a><br /></td></tr>
<tr class="separator:a73958fc3003d630fed122786da642ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66d6aed27c5b740b5e62c4bde21bb38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad66d6aed27c5b740b5e62c4bde21bb38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">const_bytes_iterator</a> = <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">ByteInterval::const_bytes_iterator</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ad66d6aed27c5b740b5e62c4bde21bb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over bytes in this block.  <a href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">More...</a><br /></td></tr>
<tr class="separator:ad66d6aed27c5b740b5e62c4bde21bb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216f200e616783a23e7f2bab7b39c482"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a216f200e616783a23e7f2bab7b39c482"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a216f200e616783a23e7f2bab7b39c482">const_bytes_range</a> = <a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">ByteInterval::const_bytes_range</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a216f200e616783a23e7f2bab7b39c482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const range over bytes in this block.  <a href="classgtirb_1_1_data_block.html#a216f200e616783a23e7f2bab7b39c482">More...</a><br /></td></tr>
<tr class="separator:a216f200e616783a23e7f2bab7b39c482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf527bbb91f1adfe4b88e7c2b0e84821"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf527bbb91f1adfe4b88e7c2b0e84821"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#a73958fc3003d630fed122786da642ee7">bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#acf527bbb91f1adfe4b88e7c2b0e84821">bytes</a> ()</td></tr>
<tr class="memdesc:acf527bbb91f1adfe4b88e7c2b0e84821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of the bytes in this block.  <a href="classgtirb_1_1_data_block.html#acf527bbb91f1adfe4b88e7c2b0e84821">More...</a><br /></td></tr>
<tr class="separator:acf527bbb91f1adfe4b88e7c2b0e84821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964141eb7183dc0208c1e6a4e7c14cec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a964141eb7183dc0208c1e6a4e7c14cec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#a216f200e616783a23e7f2bab7b39c482">const_bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a964141eb7183dc0208c1e6a4e7c14cec">bytes</a> () const</td></tr>
<tr class="memdesc:a964141eb7183dc0208c1e6a4e7c14cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of the bytes in this block.  <a href="classgtirb_1_1_data_block.html#a964141eb7183dc0208c1e6a4e7c14cec">More...</a><br /></td></tr>
<tr class="separator:a964141eb7183dc0208c1e6a4e7c14cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b060c2262368817afa7deefe9f2857"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43b060c2262368817afa7deefe9f2857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#a73958fc3003d630fed122786da642ee7">bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a43b060c2262368817afa7deefe9f2857">bytes</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:a43b060c2262368817afa7deefe9f2857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of the bytes in this block.  <a href="classgtirb_1_1_data_block.html#a43b060c2262368817afa7deefe9f2857">More...</a><br /></td></tr>
<tr class="separator:a43b060c2262368817afa7deefe9f2857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f48d101930c073b0c87d8122a0bc97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68f48d101930c073b0c87d8122a0bc97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#a216f200e616783a23e7f2bab7b39c482">const_bytes_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a68f48d101930c073b0c87d8122a0bc97">bytes</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native) const</td></tr>
<tr class="memdesc:a68f48d101930c073b0c87d8122a0bc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of the bytes in this block.  <a href="classgtirb_1_1_data_block.html#a68f48d101930c073b0c87d8122a0bc97">More...</a><br /></td></tr>
<tr class="separator:a68f48d101930c073b0c87d8122a0bc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f083dc95dcdedbca912cb3d234c974a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f083dc95dcdedbca912cb3d234c974a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a5f083dc95dcdedbca912cb3d234c974a">bytes_begin</a> ()</td></tr>
<tr class="memdesc:a5f083dc95dcdedbca912cb3d234c974a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first byte in this block.  <a href="classgtirb_1_1_data_block.html#a5f083dc95dcdedbca912cb3d234c974a">More...</a><br /></td></tr>
<tr class="separator:a5f083dc95dcdedbca912cb3d234c974a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20df7747aa367dedc2ea5b3bbf78d448"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20df7747aa367dedc2ea5b3bbf78d448"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a20df7747aa367dedc2ea5b3bbf78d448">bytes_begin</a> () const</td></tr>
<tr class="memdesc:a20df7747aa367dedc2ea5b3bbf78d448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first byte in this block.  <a href="classgtirb_1_1_data_block.html#a20df7747aa367dedc2ea5b3bbf78d448">More...</a><br /></td></tr>
<tr class="separator:a20df7747aa367dedc2ea5b3bbf78d448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1360620645e1d287ac3fd0c532a7a445"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1360620645e1d287ac3fd0c532a7a445"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a1360620645e1d287ac3fd0c532a7a445">bytes_begin</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:a1360620645e1d287ac3fd0c532a7a445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first byte in this block.  <a href="classgtirb_1_1_data_block.html#a1360620645e1d287ac3fd0c532a7a445">More...</a><br /></td></tr>
<tr class="separator:a1360620645e1d287ac3fd0c532a7a445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b8f17ab5dcace87216d8cd98923970"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59b8f17ab5dcace87216d8cd98923970"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a59b8f17ab5dcace87216d8cd98923970">bytes_begin</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native) const</td></tr>
<tr class="memdesc:a59b8f17ab5dcace87216d8cd98923970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first byte in this block.  <a href="classgtirb_1_1_data_block.html#a59b8f17ab5dcace87216d8cd98923970">More...</a><br /></td></tr>
<tr class="separator:a59b8f17ab5dcace87216d8cd98923970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f6853c0819741e50cc8b683a29187"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a348f6853c0819741e50cc8b683a29187"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a348f6853c0819741e50cc8b683a29187">bytes_end</a> ()</td></tr>
<tr class="memdesc:a348f6853c0819741e50cc8b683a29187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last byte in this block.  <a href="classgtirb_1_1_data_block.html#a348f6853c0819741e50cc8b683a29187">More...</a><br /></td></tr>
<tr class="separator:a348f6853c0819741e50cc8b683a29187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4648118b7a2b3a7a9ce16bbc20a4f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd4648118b7a2b3a7a9ce16bbc20a4f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#afd4648118b7a2b3a7a9ce16bbc20a4f0">bytes_end</a> () const</td></tr>
<tr class="memdesc:afd4648118b7a2b3a7a9ce16bbc20a4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last byte in this block.  <a href="classgtirb_1_1_data_block.html#afd4648118b7a2b3a7a9ce16bbc20a4f0">More...</a><br /></td></tr>
<tr class="separator:afd4648118b7a2b3a7a9ce16bbc20a4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe912e555c304fe6e86a958f9a773285"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe912e555c304fe6e86a958f9a773285"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#afe912e555c304fe6e86a958f9a773285">bytes_end</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native)</td></tr>
<tr class="memdesc:afe912e555c304fe6e86a958f9a773285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last byte in this block.  <a href="classgtirb_1_1_data_block.html#afe912e555c304fe6e86a958f9a773285">More...</a><br /></td></tr>
<tr class="separator:afe912e555c304fe6e86a958f9a773285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2548f5a95f5f1a727bfa982b72b6e405"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2548f5a95f5f1a727bfa982b72b6e405"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">const_bytes_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a2548f5a95f5f1a727bfa982b72b6e405">bytes_end</a> (boost::endian::order InputOrder, boost::endian::order OutputOrder=boost::endian::order::native) const</td></tr>
<tr class="memdesc:a2548f5a95f5f1a727bfa982b72b6e405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last byte in this block.  <a href="classgtirb_1_1_data_block.html#a2548f5a95f5f1a727bfa982b72b6e405">More...</a><br /></td></tr>
<tr class="separator:a2548f5a95f5f1a727bfa982b72b6e405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4705a97ab6abb69e8d2061820da4c9d9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classgtirb_1_1_addr.html">Addr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a4705a97ab6abb69e8d2061820da4c9d9">getAddress</a> () const</td></tr>
<tr class="memdesc:a4705a97ab6abb69e8d2061820da4c9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of this block, if present. See <a class="el" href="classgtirb_1_1_byte_interval.html#aaf13ececea7d2b943402feeb4f1aae35">ByteInterval::getAddress</a> for details on why this address may not be present.  <a href="classgtirb_1_1_data_block.html#a4705a97ab6abb69e8d2061820da4c9d9">More...</a><br /></td></tr>
<tr class="separator:a4705a97ab6abb69e8d2061820da4c9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2a8c5f9e07404f385710a33953541d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#adb2a8c5f9e07404f385710a33953541d">getByteInterval</a> ()</td></tr>
<tr class="memdesc:adb2a8c5f9e07404f385710a33953541d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to.  <a href="classgtirb_1_1_data_block.html#adb2a8c5f9e07404f385710a33953541d">More...</a><br /></td></tr>
<tr class="separator:adb2a8c5f9e07404f385710a33953541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9f207de0e2af740bfcdaa724b6a087"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a1c9f207de0e2af740bfcdaa724b6a087">getByteInterval</a> () const</td></tr>
<tr class="memdesc:a1c9f207de0e2af740bfcdaa724b6a087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to.  <a href="classgtirb_1_1_data_block.html#a1c9f207de0e2af740bfcdaa724b6a087">More...</a><br /></td></tr>
<tr class="separator:a1c9f207de0e2af740bfcdaa724b6a087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b65813ac786c82f4b215b39329808ef"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a1b65813ac786c82f4b215b39329808ef">getOffset</a> () const</td></tr>
<tr class="memdesc:a1b65813ac786c82f4b215b39329808ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset from the beginning of the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to.  <a href="classgtirb_1_1_data_block.html#a1b65813ac786c82f4b215b39329808ef">More...</a><br /></td></tr>
<tr class="separator:a1b65813ac786c82f4b215b39329808ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026cb5b5b74d45a406cba89e8c469b6f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a026cb5b5b74d45a406cba89e8c469b6f">getSize</a> () const</td></tr>
<tr class="memdesc:a026cb5b5b74d45a406cba89e8c469b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a>.  <a href="classgtirb_1_1_data_block.html#a026cb5b5b74d45a406cba89e8c469b6f">More...</a><br /></td></tr>
<tr class="separator:a026cb5b5b74d45a406cba89e8c469b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0706d959d13ba4213a4c41548fcdcb0a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0706d959d13ba4213a4c41548fcdcb0a"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a0706d959d13ba4213a4c41548fcdcb0a">rawBytes</a> ()</td></tr>
<tr class="memdesc:a0706d959d13ba4213a4c41548fcdcb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw data underlying this block's byte vector.  <a href="classgtirb_1_1_data_block.html#a0706d959d13ba4213a4c41548fcdcb0a">More...</a><br /></td></tr>
<tr class="separator:a0706d959d13ba4213a4c41548fcdcb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fab19c211d789bde9641589cb242026"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4fab19c211d789bde9641589cb242026"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a4fab19c211d789bde9641589cb242026">rawBytes</a> () const</td></tr>
<tr class="memdesc:a4fab19c211d789bde9641589cb242026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw data underlying this block's byte vector.  <a href="classgtirb_1_1_data_block.html#a4fab19c211d789bde9641589cb242026">More...</a><br /></td></tr>
<tr class="separator:a4fab19c211d789bde9641589cb242026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b9d976a282919b3a0fbbd35cd6a176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#ab7b9d976a282919b3a0fbbd35cd6a176">setSize</a> (uint64_t S)</td></tr>
<tr class="memdesc:ab7b9d976a282919b3a0fbbd35cd6a176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of this block.  <a href="classgtirb_1_1_data_block.html#ab7b9d976a282919b3a0fbbd35cd6a176">More...</a><br /></td></tr>
<tr class="separator:ab7b9d976a282919b3a0fbbd35cd6a176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgtirb_1_1_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgtirb_1_1_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgtirb_1_1_node.html">gtirb::Node</a></td></tr>
<tr class="memitem:a36a7eb184c437e329cd6628abd7981a3 inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a36a7eb184c437e329cd6628abd7981a3">Node</a> (const <a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;)=delete</td></tr>
<tr class="memdesc:a36a7eb184c437e329cd6628abd7981a3 inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying Nodes is explicitly disabled.  <a href="classgtirb_1_1_node.html#a36a7eb184c437e329cd6628abd7981a3">More...</a><br /></td></tr>
<tr class="separator:a36a7eb184c437e329cd6628abd7981a3 inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3e3cc413be907d848fbd839acd937c inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a9b3e3cc413be907d848fbd839acd937c">Node</a> (<a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a9b3e3cc413be907d848fbd839acd937c inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructing Nodes is explicitly disabled.  <a href="classgtirb_1_1_node.html#a9b3e3cc413be907d848fbd839acd937c">More...</a><br /></td></tr>
<tr class="separator:a9b3e3cc413be907d848fbd839acd937c inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2198c2f14d4b1bc01dfe50b0c10bdfed inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a2198c2f14d4b1bc01dfe50b0c10bdfed">~Node</a> () noexcept</td></tr>
<tr class="memdesc:a2198c2f14d4b1bc01dfe50b0c10bdfed inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up resources no longer needed by the <a class="el" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy.">Node</a> object.  <a href="classgtirb_1_1_node.html#a2198c2f14d4b1bc01dfe50b0c10bdfed">More...</a><br /></td></tr>
<tr class="separator:a2198c2f14d4b1bc01dfe50b0c10bdfed inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c1f7fbac43e778445e6a710a401700 inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#a05c1f7fbac43e778445e6a710a401700">getUUID</a> () const</td></tr>
<tr class="memdesc:a05c1f7fbac43e778445e6a710a401700 inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Universally Unique ID (UUID) for <code>this</code>.  <a href="classgtirb_1_1_node.html#a05c1f7fbac43e778445e6a710a401700">More...</a><br /></td></tr>
<tr class="separator:a05c1f7fbac43e778445e6a710a401700 inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada843ff6ad535a3f82650a4f580255e3 inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#ada843ff6ad535a3f82650a4f580255e3">operator=</a> (const <a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;)=delete</td></tr>
<tr class="memdesc:ada843ff6ad535a3f82650a4f580255e3 inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying Nodes is explicilty disabled.  <a href="classgtirb_1_1_node.html#ada843ff6ad535a3f82650a4f580255e3">More...</a><br /></td></tr>
<tr class="separator:ada843ff6ad535a3f82650a4f580255e3 inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ffe7e5d11d133b6a77a22ffc208e1c inherit pub_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#aa2ffe7e5d11d133b6a77a22ffc208e1c">operator=</a> (<a class="el" href="classgtirb_1_1_node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:aa2ffe7e5d11d133b6a77a22ffc208e1c inherit pub_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigning Nodes is explicilty disabled.  <a href="classgtirb_1_1_node.html#aa2ffe7e5d11d133b6a77a22ffc208e1c">More...</a><br /></td></tr>
<tr class="separator:aa2ffe7e5d11d133b6a77a22ffc208e1c inherit pub_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2be5c38fdd477e75c1ff8b0bafe89322"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a2be5c38fdd477e75c1ff8b0bafe89322">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C)</td></tr>
<tr class="memdesc:a2be5c38fdd477e75c1ff8b0bafe89322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an unitialized <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a> object.  <a href="classgtirb_1_1_data_block.html#a2be5c38fdd477e75c1ff8b0bafe89322">More...</a><br /></td></tr>
<tr class="separator:a2be5c38fdd477e75c1ff8b0bafe89322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2e1726f8d7c321f1a4669ad2745df4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a1c2e1726f8d7c321f1a4669ad2745df4">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, uint64_t Size)</td></tr>
<tr class="memdesc:a1c2e1726f8d7c321f1a4669ad2745df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a> object.  <a href="classgtirb_1_1_data_block.html#a1c2e1726f8d7c321f1a4669ad2745df4">More...</a><br /></td></tr>
<tr class="separator:a1c2e1726f8d7c321f1a4669ad2745df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classgtirb_1_1_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classgtirb_1_1_node')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classgtirb_1_1_node.html">gtirb::Node</a></td></tr>
<tr class="memitem:ab34e75309d3cdbae6ae783483152bf1c inherit pub_static_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#ab34e75309d3cdbae6ae783483152bf1c">Create</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C)</td></tr>
<tr class="memdesc:ab34e75309d3cdbae6ae783483152bf1c inherit pub_static_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classgtirb_1_1_node.html" title="Represents the base of the Node class hierarchy.">Node</a> object in its default state.  <a href="classgtirb_1_1_node.html#ab34e75309d3cdbae6ae783483152bf1c">More...</a><br /></td></tr>
<tr class="separator:ab34e75309d3cdbae6ae783483152bf1c inherit pub_static_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04cfa2271347cdeb3a547f829141380 inherit pub_static_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classgtirb_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#ad04cfa2271347cdeb3a547f829141380">getByUUID</a> (const <a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;Uuid)</td></tr>
<tr class="memdesc:ad04cfa2271347cdeb3a547f829141380 inherit pub_static_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a node by its UUID.  <a href="classgtirb_1_1_node.html#ad04cfa2271347cdeb3a547f829141380">More...</a><br /></td></tr>
<tr class="separator:ad04cfa2271347cdeb3a547f829141380 inherit pub_static_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea06820c30b4b70b97b317877e86d17 inherit pub_static_methods_classgtirb_1_1_node"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgtirb_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_node.html#abea06820c30b4b70b97b317877e86d17">getByUUID</a> (<a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;C, const <a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a> &amp;Uuid)</td></tr>
<tr class="memdesc:abea06820c30b4b70b97b317877e86d17 inherit pub_static_methods_classgtirb_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a node by its UUID.  <a href="classgtirb_1_1_node.html#abea06820c30b4b70b97b317877e86d17">More...</a><br /></td></tr>
<tr class="separator:abea06820c30b4b70b97b317877e86d17 inherit pub_static_methods_classgtirb_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2ed0265c4b443cda27a241352629170f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#a2ed0265c4b443cda27a241352629170f">ByteInterval</a></td></tr>
<tr class="separator:a2ed0265c4b443cda27a241352629170f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26c806e60ca4a0547680edb68f6e39b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#ac26c806e60ca4a0547680edb68f6e39b">Context</a></td></tr>
<tr class="separator:ac26c806e60ca4a0547680edb68f6e39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7995861301f2eefb390acea47c34a9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_data_block.html#aca7995861301f2eefb390acea47c34a9">SerializationTestHarness</a></td></tr>
<tr class="separator:aca7995861301f2eefb390acea47c34a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a data object, possibly symbolic. </p>
<p>Does not directly store the data bytes, which are kept in the ImageByteMap. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad7c714363704a93c8ef04c5b8c8803d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c714363704a93c8ef04c5b8c8803d0">&#9670;&nbsp;</a></span>bytes_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">gtirb::DataBlock::bytes_iterator</a> =  <a class="el" href="classgtirb_1_1_byte_interval.html#a21e0a4733ed217016369e4a56188947f">ByteInterval::bytes_iterator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over bytes in this block. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73958fc3003d630fed122786da642ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73958fc3003d630fed122786da642ee7">&#9670;&nbsp;</a></span>bytes_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_data_block.html#a73958fc3003d630fed122786da642ee7">gtirb::DataBlock::bytes_range</a> =  <a class="el" href="classgtirb_1_1_byte_interval.html#a336fa6e85522d894640e366e687ac899">ByteInterval::bytes_range</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range over bytes in this block. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad66d6aed27c5b740b5e62c4bde21bb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66d6aed27c5b740b5e62c4bde21bb38">&#9670;&nbsp;</a></span>const_bytes_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">gtirb::DataBlock::const_bytes_iterator</a> =  <a class="el" href="classgtirb_1_1_byte_interval.html#ac56b387cd5cdb902b2ecb0bc1a85103f">ByteInterval::const_bytes_iterator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator over bytes in this block. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a216f200e616783a23e7f2bab7b39c482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216f200e616783a23e7f2bab7b39c482">&#9670;&nbsp;</a></span>const_bytes_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgtirb_1_1_data_block.html#a216f200e616783a23e7f2bab7b39c482">gtirb::DataBlock::const_bytes_range</a> =  <a class="el" href="classgtirb_1_1_byte_interval.html#aa2c13a9122d82ff91df93cefaff12e47">ByteInterval::const_bytes_range</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const range over bytes in this block. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf527bbb91f1adfe4b88e7c2b0e84821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf527bbb91f1adfe4b88e7c2b0e84821">&#9670;&nbsp;</a></span>bytes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#a73958fc3003d630fed122786da642ee7">bytes_range</a>&lt;T&gt; gtirb::DataBlock::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of the bytes in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a964141eb7183dc0208c1e6a4e7c14cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964141eb7183dc0208c1e6a4e7c14cec">&#9670;&nbsp;</a></span>bytes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#a216f200e616783a23e7f2bab7b39c482">const_bytes_range</a>&lt;T&gt; gtirb::DataBlock::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of the bytes in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43b060c2262368817afa7deefe9f2857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b060c2262368817afa7deefe9f2857">&#9670;&nbsp;</a></span>bytes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#a73958fc3003d630fed122786da642ee7">bytes_range</a>&lt;T&gt; gtirb::DataBlock::bytes </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of the bytes in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68f48d101930c073b0c87d8122a0bc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f48d101930c073b0c87d8122a0bc97">&#9670;&nbsp;</a></span>bytes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#a216f200e616783a23e7f2bab7b39c482">const_bytes_range</a>&lt;T&gt; gtirb::DataBlock::bytes </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of the bytes in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f083dc95dcdedbca912cb3d234c974a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f083dc95dcdedbca912cb3d234c974a">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">bytes_iterator</a>&lt;T&gt; gtirb::DataBlock::bytes_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20df7747aa367dedc2ea5b3bbf78d448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20df7747aa367dedc2ea5b3bbf78d448">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">const_bytes_iterator</a>&lt;T&gt; gtirb::DataBlock::bytes_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1360620645e1d287ac3fd0c532a7a445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1360620645e1d287ac3fd0c532a7a445">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">bytes_iterator</a>&lt;T&gt; gtirb::DataBlock::bytes_begin </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59b8f17ab5dcace87216d8cd98923970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b8f17ab5dcace87216d8cd98923970">&#9670;&nbsp;</a></span>bytes_begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">const_bytes_iterator</a>&lt;T&gt; gtirb::DataBlock::bytes_begin </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a348f6853c0819741e50cc8b683a29187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348f6853c0819741e50cc8b683a29187">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">bytes_iterator</a>&lt;T&gt; gtirb::DataBlock::bytes_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd4648118b7a2b3a7a9ce16bbc20a4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4648118b7a2b3a7a9ce16bbc20a4f0">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">const_bytes_iterator</a>&lt;T&gt; gtirb::DataBlock::bytes_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe912e555c304fe6e86a958f9a773285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe912e555c304fe6e86a958f9a773285">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#ad7c714363704a93c8ef04c5b8c8803d0">bytes_iterator</a>&lt;T&gt; gtirb::DataBlock::bytes_end </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2548f5a95f5f1a727bfa982b72b6e405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2548f5a95f5f1a727bfa982b72b6e405">&#9670;&nbsp;</a></span>bytes_end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_data_block.html#ad66d6aed27c5b740b5e62c4bde21bb38">const_bytes_iterator</a>&lt;T&gt; gtirb::DataBlock::bytes_end </td>
          <td>(</td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>InputOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::endian::order&#160;</td>
          <td class="paramname"><em>OutputOrder</em> = <code>boost::endian::order::native</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last byte in this block. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type that satisfies Boost's EndianReversible concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputOrder</td><td>The endianness of the data in the block. </td></tr>
    <tr><td class="paramname">OutputOrder</td><td>The endianness you wish to read out from the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2be5c38fdd477e75c1ff8b0bafe89322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be5c38fdd477e75c1ff8b0bafe89322">&#9670;&nbsp;</a></span>Create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>* gtirb::DataBlock::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an unitialized <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html" title="The context under which GTIRB operations occur.">Context</a> in which this <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a> will be held. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a>. </dd></dl>

</div>
</div>
<a id="a1c2e1726f8d7c321f1a4669ad2745df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2e1726f8d7c321f1a4669ad2745df4">&#9670;&nbsp;</a></span>Create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgtirb_1_1_data_block.html">DataBlock</a>* gtirb::DataBlock::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgtirb_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The <a class="el" href="classgtirb_1_1_context.html" title="The context under which GTIRB operations occur.">Context</a> in which the newly-created <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a> will be </td></tr>
    <tr><td class="paramname">Size</td><td>The size of the object in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a>. </dd></dl>

</div>
</div>
<a id="a4705a97ab6abb69e8d2061820da4c9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4705a97ab6abb69e8d2061820da4c9d9">&#9670;&nbsp;</a></span>getAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classgtirb_1_1_addr.html">Addr</a>&gt; gtirb::DataBlock::getAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address of this block, if present. See <a class="el" href="classgtirb_1_1_byte_interval.html#aaf13ececea7d2b943402feeb4f1aae35">ByteInterval::getAddress</a> for details on why this address may not be present. </p>

</div>
</div>
<a id="adb2a8c5f9e07404f385710a33953541d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2a8c5f9e07404f385710a33953541d">&#9670;&nbsp;</a></span>getByteInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>* gtirb::DataBlock::getByteInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to. </p>

</div>
</div>
<a id="a1c9f207de0e2af740bfcdaa724b6a087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9f207de0e2af740bfcdaa724b6a087">&#9670;&nbsp;</a></span>getByteInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>* gtirb::DataBlock::getByteInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to. </p>

</div>
</div>
<a id="a1b65813ac786c82f4b215b39329808ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b65813ac786c82f4b215b39329808ef">&#9670;&nbsp;</a></span>getOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gtirb::DataBlock::getOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the offset from the beginning of the <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a> this block belongs to. </p>

</div>
</div>
<a id="a026cb5b5b74d45a406cba89e8c469b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026cb5b5b74d45a406cba89e8c469b6f">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gtirb::DataBlock::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a <a class="el" href="classgtirb_1_1_data_block.html" title="Represents a data object, possibly symbolic.">DataBlock</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The size. </dd></dl>

</div>
</div>
<a id="a0706d959d13ba4213a4c41548fcdcb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0706d959d13ba4213a4c41548fcdcb0a">&#9670;&nbsp;</a></span>rawBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* gtirb::DataBlock::rawBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the raw data underlying this block's byte vector. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<p>Much like std::vector::data, this function is low-level and potentially unsafe. This pointer refers to valid memory only where an iterator would be valid to point to. Modifying the size of the byte vector may invalidate this pointer. Any endian conversions will not be performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type.</td></tr>
  </table>
  </dd>
</dl>
<p>\retrurn A pointer to raw data. </p>

</div>
</div>
<a id="a4fab19c211d789bde9641589cb242026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fab19c211d789bde9641589cb242026">&#9670;&nbsp;</a></span>rawBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* gtirb::DataBlock::rawBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the raw data underlying this block's byte vector. </p>
<p>If this block is not associated with any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>, than the behavior of this function is undefined.</p>
<p>Much like std::vector::data, this function is low-level and potentially unsafe. This pointer refers to valid memory only where an iterator would be valid to point to. Modifying the size of the byte vector may invalidate this pointer. Any endian conversions will not be performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in this block's byte vector. Must be a POD type.</td></tr>
  </table>
  </dd>
</dl>
<p>\retrurn A pointer to raw data. </p>

</div>
</div>
<a id="ab7b9d976a282919b3a0fbbd35cd6a176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b9d976a282919b3a0fbbd35cd6a176">&#9670;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtirb::DataBlock::setSize </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of this block. </p>
<p>Note that this does not automatically update any <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>'s size, bytes, or symbolic expressions. This simply changes the extents of a block in its <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2ed0265c4b443cda27a241352629170f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed0265c4b443cda27a241352629170f">&#9670;&nbsp;</a></span>ByteInterval</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgtirb_1_1_byte_interval.html">ByteInterval</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac26c806e60ca4a0547680edb68f6e39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26c806e60ca4a0547680edb68f6e39b">&#9670;&nbsp;</a></span>Context</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgtirb_1_1_context.html">Context</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca7995861301f2eefb390acea47c34a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7995861301f2eefb390acea47c34a9">&#9670;&nbsp;</a></span>SerializationTestHarness</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SerializationTestHarness</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_data_block_8hpp_source.html">DataBlock.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
