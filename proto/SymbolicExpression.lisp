
;;;;    SymbolicExpression.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:gtirb.proto)
    (make-package '#:gtirb.proto :use nil)))
(in-package #:gtirb.proto)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:defclass sym-stack-const (pb:protocol-buffer)
  (
  (offset
   :accessor offset
   :initform 0
   :type (cl:signed-byte 32))
  (symbol-uuid
   :accessor symbol-uuid
   :initform (cl:make-array 0 :element-type '(cl:unsigned-byte 8))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'sym-stack-const))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'offset))


(cl:defmethod (cl:setf offset) :after (x (self sym-stack-const))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-offset)
  (cl:defgeneric has-offset (proto)))
(cl:defmethod has-offset ((self sym-stack-const))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-offset))

(cl:unless (cl:fboundp 'clear-offset)
  (cl:defgeneric clear-offset (proto)))
(cl:defmethod clear-offset ((self sym-stack-const))
  (cl:setf (cl:slot-value self 'offset) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-offset))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'symbol-uuid))


(cl:defmethod (cl:setf symbol-uuid) :after (x (self sym-stack-const))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-symbol-uuid)
  (cl:defgeneric has-symbol-uuid (proto)))
(cl:defmethod has-symbol-uuid ((self sym-stack-const))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-symbol-uuid))

(cl:unless (cl:fboundp 'clear-symbol-uuid)
  (cl:defgeneric clear-symbol-uuid (proto)))
(cl:defmethod clear-symbol-uuid ((self sym-stack-const))
  (cl:setf (cl:slot-value self 'symbol-uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8)))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-symbol-uuid))


(cl:defmethod cl:print-object ((self sym-stack-const) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_offset: ~s" (offset self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_symbol-uuid: ~s" (symbol-uuid self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self sym-stack-const))
  (cl:setf (cl:slot-value self 'offset) 0)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'symbol-uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8))))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self sym-stack-const))
  cl:t)

(cl:defmethod pb:octet-size ((self sym-stack-const))
  (cl:let ((size 0))
    ;; int32 offset = 1[json_name = "offset"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'offset))))))
    ;; bytes symbol_uuid = 2[json_name = "symbolUuid"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'symbol-uuid))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self sym-stack-const) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; int32 offset = 1[json_name = "offset"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'offset)))))
  ;; bytes symbol_uuid = 2[json_name = "symbolUuid"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'symbol-uuid))))
  index)

(cl:defmethod pb:merge-from-array ((self sym-stack-const) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; int32 offset = 1[json_name = "offset"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int32-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'offset) value)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; bytes symbol_uuid = 2[json_name = "symbolUuid"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'symbol-uuid) value)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self sym-stack-const) (from sym-stack-const))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'offset) (cl:slot-value from 'offset))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'symbol-uuid) (cl:slot-value from 'symbol-uuid))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  )


(cl:defclass sym-addr-const (pb:protocol-buffer)
  (
  (offset
   :accessor offset
   :initform 0
   :type (cl:signed-byte 64))
  (symbol-uuid
   :accessor symbol-uuid
   :initform (cl:make-array 0 :element-type '(cl:unsigned-byte 8))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'sym-addr-const))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'offset))


(cl:defmethod (cl:setf offset) :after (x (self sym-addr-const))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-offset)
  (cl:defgeneric has-offset (proto)))
(cl:defmethod has-offset ((self sym-addr-const))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-offset))

(cl:unless (cl:fboundp 'clear-offset)
  (cl:defgeneric clear-offset (proto)))
(cl:defmethod clear-offset ((self sym-addr-const))
  (cl:setf (cl:slot-value self 'offset) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-offset))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'symbol-uuid))


(cl:defmethod (cl:setf symbol-uuid) :after (x (self sym-addr-const))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-symbol-uuid)
  (cl:defgeneric has-symbol-uuid (proto)))
(cl:defmethod has-symbol-uuid ((self sym-addr-const))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-symbol-uuid))

(cl:unless (cl:fboundp 'clear-symbol-uuid)
  (cl:defgeneric clear-symbol-uuid (proto)))
(cl:defmethod clear-symbol-uuid ((self sym-addr-const))
  (cl:setf (cl:slot-value self 'symbol-uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8)))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-symbol-uuid))


(cl:defmethod cl:print-object ((self sym-addr-const) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_offset: ~s" (offset self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_symbol-uuid: ~s" (symbol-uuid self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self sym-addr-const))
  (cl:setf (cl:slot-value self 'offset) 0)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'symbol-uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8))))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self sym-addr-const))
  cl:t)

(cl:defmethod pb:octet-size ((self sym-addr-const))
  (cl:let ((size 0))
    ;; int64 offset = 1[json_name = "offset"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'offset))))))
    ;; bytes symbol_uuid = 2[json_name = "symbolUuid"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'symbol-uuid))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self sym-addr-const) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; int64 offset = 1[json_name = "offset"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'offset)))))
  ;; bytes symbol_uuid = 2[json_name = "symbolUuid"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'symbol-uuid))))
  index)

(cl:defmethod pb:merge-from-array ((self sym-addr-const) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; int64 offset = 1[json_name = "offset"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'offset) value)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; bytes symbol_uuid = 2[json_name = "symbolUuid"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'symbol-uuid) value)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self sym-addr-const) (from sym-addr-const))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'offset) (cl:slot-value from 'offset))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'symbol-uuid) (cl:slot-value from 'symbol-uuid))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  )


(cl:defclass sym-addr-addr (pb:protocol-buffer)
  (
  (scale
   :accessor scale
   :initform 0
   :type (cl:signed-byte 64))
  (offset
   :accessor offset
   :initform 0
   :type (cl:signed-byte 64))
  (symbol1-uuid
   :accessor symbol1-uuid
   :initform (cl:make-array 0 :element-type '(cl:unsigned-byte 8))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (symbol2-uuid
   :accessor symbol2-uuid
   :initform (cl:make-array 0 :element-type '(cl:unsigned-byte 8))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 4))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'sym-addr-addr))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'scale))


(cl:defmethod (cl:setf scale) :after (x (self sym-addr-addr))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-scale)
  (cl:defgeneric has-scale (proto)))
(cl:defmethod has-scale ((self sym-addr-addr))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-scale))

(cl:unless (cl:fboundp 'clear-scale)
  (cl:defgeneric clear-scale (proto)))
(cl:defmethod clear-scale ((self sym-addr-addr))
  (cl:setf (cl:slot-value self 'scale) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-scale))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'offset))


(cl:defmethod (cl:setf offset) :after (x (self sym-addr-addr))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-offset)
  (cl:defgeneric has-offset (proto)))
(cl:defmethod has-offset ((self sym-addr-addr))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-offset))

(cl:unless (cl:fboundp 'clear-offset)
  (cl:defgeneric clear-offset (proto)))
(cl:defmethod clear-offset ((self sym-addr-addr))
  (cl:setf (cl:slot-value self 'offset) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-offset))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'symbol1-uuid))


(cl:defmethod (cl:setf symbol1-uuid) :after (x (self sym-addr-addr))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-symbol1-uuid)
  (cl:defgeneric has-symbol1-uuid (proto)))
(cl:defmethod has-symbol1-uuid ((self sym-addr-addr))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-symbol1-uuid))

(cl:unless (cl:fboundp 'clear-symbol1-uuid)
  (cl:defgeneric clear-symbol1-uuid (proto)))
(cl:defmethod clear-symbol1-uuid ((self sym-addr-addr))
  (cl:setf (cl:slot-value self 'symbol1-uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8)))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-symbol1-uuid))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'symbol2-uuid))


(cl:defmethod (cl:setf symbol2-uuid) :after (x (self sym-addr-addr))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-symbol2-uuid)
  (cl:defgeneric has-symbol2-uuid (proto)))
(cl:defmethod has-symbol2-uuid ((self sym-addr-addr))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-symbol2-uuid))

(cl:unless (cl:fboundp 'clear-symbol2-uuid)
  (cl:defgeneric clear-symbol2-uuid (proto)))
(cl:defmethod clear-symbol2-uuid ((self sym-addr-addr))
  (cl:setf (cl:slot-value self 'symbol2-uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8)))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-symbol2-uuid))


(cl:defmethod cl:print-object ((self sym-addr-addr) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_scale: ~s" (scale self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_offset: ~s" (offset self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_symbol1-uuid: ~s" (symbol1-uuid self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_symbol2-uuid: ~s" (symbol2-uuid self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self sym-addr-addr))
  (cl:setf (cl:slot-value self 'scale) 0)
  (cl:setf (cl:slot-value self 'offset) 0)
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'symbol1-uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8))))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'symbol2-uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8))))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self sym-addr-addr))
  cl:t)

(cl:defmethod pb:octet-size ((self sym-addr-addr))
  (cl:let ((size 0))
    ;; int64 scale = 1[json_name = "scale"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'scale))))))
    ;; int64 offset = 2[json_name = "offset"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'offset))))))
    ;; bytes symbol1_uuid = 3[json_name = "symbol1Uuid"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'symbol1-uuid))))
        (cl:+ s (varint:length32 s)))))
    ;; bytes symbol2_uuid = 4[json_name = "symbol2Uuid"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'symbol2-uuid))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self sym-addr-addr) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; int64 scale = 1[json_name = "scale"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'scale)))))
  ;; int64 offset = 2[json_name = "offset"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'offset)))))
  ;; bytes symbol1_uuid = 3[json_name = "symbol1Uuid"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'symbol1-uuid))))
  ;; bytes symbol2_uuid = 4[json_name = "symbol2Uuid"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'symbol2-uuid))))
  index)

(cl:defmethod pb:merge-from-array ((self sym-addr-addr) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; int64 scale = 1[json_name = "scale"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'scale) value)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; int64 offset = 2[json_name = "offset"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'offset) value)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; bytes symbol1_uuid = 3[json_name = "symbol1Uuid"];
        ((3)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'symbol1-uuid) value)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; bytes symbol2_uuid = 4[json_name = "symbol2Uuid"];
        ((4)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'symbol2-uuid) value)
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self sym-addr-addr) (from sym-addr-addr))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'scale) (cl:slot-value from 'scale))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'offset) (cl:slot-value from 'offset))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'symbol1-uuid) (cl:slot-value from 'symbol1-uuid))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'symbol2-uuid) (cl:slot-value from 'symbol2-uuid))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  )


(cl:defclass symbolic-expression (pb:protocol-buffer)
  (
  (stack-const
   :writer (cl:setf stack-const)
   :initform cl:nil
   :type (cl:or cl:null gtirb.proto::sym-stack-const))
  (addr-const
   :writer (cl:setf addr-const)
   :initform cl:nil
   :type (cl:or cl:null gtirb.proto::sym-addr-const))
  (addr-addr
   :writer (cl:setf addr-addr)
   :initform cl:nil
   :type (cl:or cl:null gtirb.proto::sym-addr-addr))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'symbolic-expression))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'stack-const))

(cl:unless (cl:fboundp 'stack-const)
  (cl:defgeneric stack-const (proto)))
(cl:defmethod stack-const ((self symbolic-expression))
  (cl:let ((result (cl:slot-value self 'stack-const)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'gtirb.proto::sym-stack-const))
      (cl:setf (cl:slot-value self 'stack-const) result))
      (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf stack-const) :after (x (self symbolic-expression))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-stack-const)
  (cl:defgeneric has-stack-const (proto)))
(cl:defmethod has-stack-const ((self symbolic-expression))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-stack-const))

(cl:unless (cl:fboundp 'clear-stack-const)
  (cl:defgeneric clear-stack-const (proto)))
(cl:defmethod clear-stack-const ((self symbolic-expression))
  (cl:setf (cl:slot-value self 'stack-const) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-stack-const))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'addr-const))

(cl:unless (cl:fboundp 'addr-const)
  (cl:defgeneric addr-const (proto)))
(cl:defmethod addr-const ((self symbolic-expression))
  (cl:let ((result (cl:slot-value self 'addr-const)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'gtirb.proto::sym-addr-const))
      (cl:setf (cl:slot-value self 'addr-const) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf addr-const) :after (x (self symbolic-expression))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-addr-const)
  (cl:defgeneric has-addr-const (proto)))
(cl:defmethod has-addr-const ((self symbolic-expression))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-addr-const))

(cl:unless (cl:fboundp 'clear-addr-const)
  (cl:defgeneric clear-addr-const (proto)))
(cl:defmethod clear-addr-const ((self symbolic-expression))
  (cl:setf (cl:slot-value self 'addr-const) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-addr-const))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'addr-addr))

(cl:unless (cl:fboundp 'addr-addr)
  (cl:defgeneric addr-addr (proto)))
(cl:defmethod addr-addr ((self symbolic-expression))
  (cl:let ((result (cl:slot-value self 'addr-addr)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'gtirb.proto::sym-addr-addr))
      (cl:setf (cl:slot-value self 'addr-addr) result))
      (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf addr-addr) :after (x (self symbolic-expression))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-addr-addr)
  (cl:defgeneric has-addr-addr (proto)))
(cl:defmethod has-addr-addr ((self symbolic-expression))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-addr-addr))

(cl:unless (cl:fboundp 'clear-addr-addr)
  (cl:defgeneric clear-addr-addr (proto)))
(cl:defmethod clear-addr-addr ((self symbolic-expression))
  (cl:setf (cl:slot-value self 'addr-addr) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-addr-addr))


(cl:defmethod cl:print-object ((self symbolic-expression) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_stack-const: ~s" (stack-const self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_addr-const: ~s" (addr-const self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_addr-addr: ~s" (addr-addr self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self symbolic-expression))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'stack-const) cl:nil))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'addr-const) cl:nil))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'addr-addr) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self symbolic-expression))
  cl:t)

(cl:defmethod pb:octet-size ((self symbolic-expression))
  (cl:let ((size 0))
    ;; .gtirb.proto.SymStackConst stack_const = 1[json_name = "stackConst"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'stack-const))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .gtirb.proto.SymAddrConst addr_const = 2[json_name = "addrConst"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'addr-const))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .gtirb.proto.SymAddrAddr addr_addr = 3[json_name = "addrAddr"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'addr-addr))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self symbolic-expression) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .gtirb.proto.SymStackConst stack_const = 1[json_name = "stackConst"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'stack-const) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'stack-const) buffer index limit)))
  ;; .gtirb.proto.SymAddrConst addr_const = 2[json_name = "addrConst"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'addr-const) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'addr-const) buffer index limit)))
  ;; .gtirb.proto.SymAddrAddr addr_addr = 3[json_name = "addrAddr"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'addr-addr) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'addr-addr) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self symbolic-expression) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; .gtirb.proto.SymStackConst stack_const = 1[json_name = "stackConst"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:slot-value self 'stack-const)))
                  (cl:when (cl:null message)
                    (cl:setf message (cl:make-instance 'gtirb.proto::sym-stack-const))
                    (cl:setf (cl:slot-value self 'stack-const) message)
                    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; .gtirb.proto.SymAddrConst addr_const = 2[json_name = "addrConst"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:slot-value self 'addr-const)))
                  (cl:when (cl:null message)
                    (cl:setf message (cl:make-instance 'gtirb.proto::sym-addr-const))
                    (cl:setf (cl:slot-value self 'addr-const) message)
                    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; .gtirb.proto.SymAddrAddr addr_addr = 3[json_name = "addrAddr"];
        ((3)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:slot-value self 'addr-addr)))
                  (cl:when (cl:null message)
                    (cl:setf message (cl:make-instance 'gtirb.proto::sym-addr-addr))
                    (cl:setf (cl:slot-value self 'addr-addr) message)
                    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment)))))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self symbolic-expression) (from symbolic-expression))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'stack-const)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'gtirb.proto::sym-stack-const))
        (cl:setf (cl:slot-value self 'stack-const) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'stack-const))))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'addr-const)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'gtirb.proto::sym-addr-const))
        (cl:setf (cl:slot-value self 'addr-const) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'addr-const))))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'addr-addr)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'gtirb.proto::sym-addr-addr))
        (cl:setf (cl:slot-value self 'addr-addr) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'addr-addr))))
  )


