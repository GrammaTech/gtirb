
;;;;    ImageByteMap.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:proto-v0)
    (make-package '#:proto-v0 :use nil)))
(in-package #:proto-v0)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:defclass image-byte-map (pb:protocol-buffer)
  (
  (uuid
   :accessor uuid
   :initform (cl:make-array 0 :element-type '(cl:unsigned-byte 8))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (byte-map
   :writer (cl:setf byte-map)
   :initform cl:nil
   :type (cl:or cl:null proto-v0::byte-map))
  (addr-min
   :accessor addr-min
   :initform 0
   :type (cl:unsigned-byte 64))
  (addr-max
   :accessor addr-max
   :initform 0
   :type (cl:unsigned-byte 64))
  (base-address
   :accessor base-address
   :initform 0
   :type (cl:unsigned-byte 64))
  (entry-point-address
   :accessor entry-point-address
   :initform 0
   :type (cl:unsigned-byte 64))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 6))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'image-byte-map))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'uuid))


(cl:defmethod (cl:setf uuid) :after (x (self image-byte-map))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-uuid)
  (cl:defgeneric has-uuid (proto)))
(cl:defmethod has-uuid ((self image-byte-map))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-uuid))

(cl:unless (cl:fboundp 'clear-uuid)
  (cl:defgeneric clear-uuid (proto)))
(cl:defmethod clear-uuid ((self image-byte-map))
  (cl:setf (cl:slot-value self 'uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8)))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-uuid))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'byte-map))

(cl:unless (cl:fboundp 'byte-map)
  (cl:defgeneric byte-map (proto)))
(cl:defmethod byte-map ((self image-byte-map))
  (cl:let ((result (cl:slot-value self 'byte-map)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'proto-v0::byte-map))
      (cl:setf (cl:slot-value self 'byte-map) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf byte-map) :after (x (self image-byte-map))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-byte-map)
  (cl:defgeneric has-byte-map (proto)))
(cl:defmethod has-byte-map ((self image-byte-map))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-byte-map))

(cl:unless (cl:fboundp 'clear-byte-map)
  (cl:defgeneric clear-byte-map (proto)))
(cl:defmethod clear-byte-map ((self image-byte-map))
  (cl:setf (cl:slot-value self 'byte-map) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-byte-map))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'addr-min))


(cl:defmethod (cl:setf addr-min) :after (x (self image-byte-map))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-addr-min)
  (cl:defgeneric has-addr-min (proto)))
(cl:defmethod has-addr-min ((self image-byte-map))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-addr-min))

(cl:unless (cl:fboundp 'clear-addr-min)
  (cl:defgeneric clear-addr-min (proto)))
(cl:defmethod clear-addr-min ((self image-byte-map))
  (cl:setf (cl:slot-value self 'addr-min) 0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-addr-min))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'addr-max))


(cl:defmethod (cl:setf addr-max) :after (x (self image-byte-map))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-addr-max)
  (cl:defgeneric has-addr-max (proto)))
(cl:defmethod has-addr-max ((self image-byte-map))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-addr-max))

(cl:unless (cl:fboundp 'clear-addr-max)
  (cl:defgeneric clear-addr-max (proto)))
(cl:defmethod clear-addr-max ((self image-byte-map))
  (cl:setf (cl:slot-value self 'addr-max) 0)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-addr-max))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'base-address))


(cl:defmethod (cl:setf base-address) :after (x (self image-byte-map))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-base-address)
  (cl:defgeneric has-base-address (proto)))
(cl:defmethod has-base-address ((self image-byte-map))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-base-address))

(cl:unless (cl:fboundp 'clear-base-address)
  (cl:defgeneric clear-base-address (proto)))
(cl:defmethod clear-base-address ((self image-byte-map))
  (cl:setf (cl:slot-value self 'base-address) 0)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-base-address))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'entry-point-address))


(cl:defmethod (cl:setf entry-point-address) :after (x (self image-byte-map))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-entry-point-address)
  (cl:defgeneric has-entry-point-address (proto)))
(cl:defmethod has-entry-point-address ((self image-byte-map))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-entry-point-address))

(cl:unless (cl:fboundp 'clear-entry-point-address)
  (cl:defgeneric clear-entry-point-address (proto)))
(cl:defmethod clear-entry-point-address ((self image-byte-map))
  (cl:setf (cl:slot-value self 'entry-point-address) 0)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-entry-point-address))


(cl:defmethod cl:print-object ((self image-byte-map) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_uuid: ~s" (uuid self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_byte-map: ~s" (byte-map self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_addr-min: ~s" (addr-min self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_addr-max: ~s" (addr-max self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_base-address: ~s" (base-address self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_entry-point-address: ~s" (entry-point-address self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self image-byte-map))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8))))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'byte-map) cl:nil))
  (cl:setf (cl:slot-value self 'addr-min) 0)
  (cl:setf (cl:slot-value self 'addr-max) 0)
  (cl:setf (cl:slot-value self 'base-address) 0)
  (cl:setf (cl:slot-value self 'entry-point-address) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self image-byte-map))
  cl:t)

(cl:defmethod pb:octet-size ((self image-byte-map))
  (cl:let ((size 0))
    ;; bytes uuid = 1[json_name = "uuid"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'uuid))))
        (cl:+ s (varint:length32 s)))))
    ;; .protoV0.ByteMap byte_map = 2[json_name = "byteMap"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'byte-map))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; uint64 addr_min = 3[json_name = "addrMin"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'addr-min)))))
    ;; uint64 addr_max = 4[json_name = "addrMax"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'addr-max)))))
    ;; uint64 base_address = 5[json_name = "baseAddress"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'base-address)))))
    ;; uint64 entry_point_address = 6[json_name = "entryPointAddress"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'entry-point-address)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self image-byte-map) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; bytes uuid = 1[json_name = "uuid"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'uuid))))
  ;; .protoV0.ByteMap byte_map = 2[json_name = "byteMap"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'byte-map) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'byte-map) buffer index limit)))
  ;; uint64 addr_min = 3[json_name = "addrMin"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'addr-min))))
  ;; uint64 addr_max = 4[json_name = "addrMax"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'addr-max))))
  ;; uint64 base_address = 5[json_name = "baseAddress"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'base-address))))
  ;; uint64 entry_point_address = 6[json_name = "entryPointAddress"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'entry-point-address))))
  index)

(cl:defmethod pb:merge-from-array ((self image-byte-map) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; bytes uuid = 1[json_name = "uuid"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'uuid) value)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; .protoV0.ByteMap byte_map = 2[json_name = "byteMap"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:slot-value self 'byte-map)))
                  (cl:when (cl:null message)
                    (cl:setf message (cl:make-instance 'proto-v0::byte-map))
                    (cl:setf (cl:slot-value self 'byte-map) message)
                    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; uint64 addr_min = 3[json_name = "addrMin"];
        ((3)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-uint64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'addr-min) value)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; uint64 addr_max = 4[json_name = "addrMax"];
        ((4)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-uint64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'addr-max) value)
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; uint64 base_address = 5[json_name = "baseAddress"];
        ((5)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-uint64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'base-address) value)
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; uint64 entry_point_address = 6[json_name = "entryPointAddress"];
        ((6)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-uint64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'entry-point-address) value)
                (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self image-byte-map) (from image-byte-map))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'uuid) (cl:slot-value from 'uuid))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'byte-map)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'proto-v0::byte-map))
        (cl:setf (cl:slot-value self 'byte-map) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'byte-map))))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'addr-min) (cl:slot-value from 'addr-min))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'addr-max) (cl:slot-value from 'addr-max))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'base-address) (cl:slot-value from 'base-address))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'entry-point-address) (cl:slot-value from 'entry-point-address))
    (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
  )


