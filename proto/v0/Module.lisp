
;;;;    Module.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:proto-v0)
    (make-package '#:proto-v0 :use nil)))
(in-package #:proto-v0)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:deftype file-format () '(cl:member 0 1 2 3 4 5 6 7 8))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'file-format))

(cl:defconstant +file-format-format-undefined+ 0)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+file-format-format-undefined+))
(cl:defconstant +file-format-coff+ 1)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+file-format-coff+))
(cl:defconstant +file-format-elf+ 2)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+file-format-elf+))
(cl:defconstant +file-format-pe+ 3)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+file-format-pe+))
(cl:defconstant +file-format-ida-pro-db32+ 4)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+file-format-ida-pro-db32+))
(cl:defconstant +file-format-ida-pro-db64+ 5)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+file-format-ida-pro-db64+))
(cl:defconstant +file-format-xcoff+ 6)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+file-format-xcoff+))
(cl:defconstant +file-format-macho+ 7)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+file-format-macho+))
(cl:defconstant +file-format-raw+ 8)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+file-format-raw+))

(cl:defconstant +minimum-file-format+ +file-format-format-undefined+)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+minimum-file-format+))
(cl:defconstant +maximum-file-format+ +file-format-raw+)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+maximum-file-format+))

(cl:deftype isaid () '(cl:member 0 1 2 3 4 5))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'isaid))

(cl:defconstant +isaid-isa-undefined+ 0)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+isaid-isa-undefined+))
(cl:defconstant +isaid-ia32+ 1)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+isaid-ia32+))
(cl:defconstant +isaid-ppc32+ 2)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+isaid-ppc32+))
(cl:defconstant +isaid-x64+ 3)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+isaid-x64+))
(cl:defconstant +isaid-arm+ 4)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+isaid-arm+))
(cl:defconstant +isaid-valid-but-unsupported+ 5)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+isaid-valid-but-unsupported+))

(cl:defconstant +minimum-isaid+ +isaid-isa-undefined+)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+minimum-isaid+))
(cl:defconstant +maximum-isaid+ +isaid-valid-but-unsupported+)
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export '+maximum-isaid+))

(cl:defclass module-symbolic-operands-entry (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform 0
   :type (cl:unsigned-byte 64))
  (value
   :writer (cl:setf value)
   :initform cl:nil
   :type (cl:or cl:null proto-v0::symbolic-expression))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'module-symbolic-operands-entry))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'key))


(cl:defmethod (cl:setf key) :after (x (self module-symbolic-operands-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self module-symbolic-operands-entry))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-key))

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self module-symbolic-operands-entry))
  (cl:setf (cl:slot-value self 'key) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-key))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'value))

(cl:unless (cl:fboundp 'value)
  (cl:defgeneric value (proto)))
(cl:defmethod value ((self module-symbolic-operands-entry))
  (cl:let ((result (cl:slot-value self 'value)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'proto-v0::symbolic-expression))
      (cl:setf (cl:slot-value self 'value) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf value) :after (x (self module-symbolic-operands-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self module-symbolic-operands-entry))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-value))

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self module-symbolic-operands-entry))
  (cl:setf (cl:slot-value self 'value) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-value))



(cl:defclass module (pb:protocol-buffer)
  (
  (uuid
   :accessor uuid
   :initform (cl:make-array 0 :element-type '(cl:unsigned-byte 8))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (binary-path
   :accessor binary-path
   :initform (pb:string-field "")
   :type pb::%sf%)
  (preferred-addr
   :accessor preferred-addr
   :initform 0
   :type (cl:unsigned-byte 64))
  (rebase-delta
   :accessor rebase-delta
   :initform 0
   :type (cl:signed-byte 64))
  (file-format
   :accessor file-format
   :initform proto-v0::+file-format-format-undefined+
   :type proto-v0::file-format)
  (isa-id
   :accessor isa-id
   :initform proto-v0::+isaid-isa-undefined+
   :type proto-v0::isaid)
  (name
   :accessor name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (image-byte-map
   :writer (cl:setf image-byte-map)
   :initform cl:nil
   :type (cl:or cl:null proto-v0::image-byte-map))
  (symbols
   :accessor symbols
   :initform (cl:make-array
              0
              :element-type 'proto-v0::symbol
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector proto-v0::symbol))
  (cfg
   :writer (cl:setf cfg)
   :initform cl:nil
   :type (cl:or cl:null proto-v0::cfg))
  (blocks
   :accessor blocks
   :initform (cl:make-array
              0
              :element-type 'proto-v0::block
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector proto-v0::block))
  (data
   :accessor data
   :initform (cl:make-array
              0
              :element-type 'proto-v0::data-object
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector proto-v0::data-object))
  (proxies
   :accessor proxies
   :initform (cl:make-array
              0
              :element-type 'proto-v0::proxy-block
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector proto-v0::proxy-block))
  (sections
   :accessor sections
   :initform (cl:make-array
              0
              :element-type 'proto-v0::section
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector proto-v0::section))
  (symbolic-operands
   :accessor symbolic-operands
   :initform (cl:make-array
              0
              :element-type 'proto-v0::module-symbolic-operands-entry
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector proto-v0::module-symbolic-operands-entry))
  (aux-data-container
   :writer (cl:setf aux-data-container)
   :initform cl:nil
   :type (cl:or cl:null proto-v0::aux-data-container))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 16))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'module))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'uuid))


(cl:defmethod (cl:setf uuid) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-uuid)
  (cl:defgeneric has-uuid (proto)))
(cl:defmethod has-uuid ((self module))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-uuid))

(cl:unless (cl:fboundp 'clear-uuid)
  (cl:defgeneric clear-uuid (proto)))
(cl:defmethod clear-uuid ((self module))
  (cl:setf (cl:slot-value self 'uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8)))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-uuid))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'binary-path))


(cl:defmethod (cl:setf binary-path) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-binary-path)
  (cl:defgeneric has-binary-path (proto)))
(cl:defmethod has-binary-path ((self module))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-binary-path))

(cl:unless (cl:fboundp 'clear-binary-path)
  (cl:defgeneric clear-binary-path (proto)))
(cl:defmethod clear-binary-path ((self module))
  (cl:setf (cl:slot-value self 'binary-path) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-binary-path))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'preferred-addr))


(cl:defmethod (cl:setf preferred-addr) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-preferred-addr)
  (cl:defgeneric has-preferred-addr (proto)))
(cl:defmethod has-preferred-addr ((self module))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-preferred-addr))

(cl:unless (cl:fboundp 'clear-preferred-addr)
  (cl:defgeneric clear-preferred-addr (proto)))
(cl:defmethod clear-preferred-addr ((self module))
  (cl:setf (cl:slot-value self 'preferred-addr) 0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-preferred-addr))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'rebase-delta))


(cl:defmethod (cl:setf rebase-delta) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-rebase-delta)
  (cl:defgeneric has-rebase-delta (proto)))
(cl:defmethod has-rebase-delta ((self module))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-rebase-delta))

(cl:unless (cl:fboundp 'clear-rebase-delta)
  (cl:defgeneric clear-rebase-delta (proto)))
(cl:defmethod clear-rebase-delta ((self module))
  (cl:setf (cl:slot-value self 'rebase-delta) 0)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-rebase-delta))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'file-format))


(cl:defmethod (cl:setf file-format) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-file-format)
  (cl:defgeneric has-file-format (proto)))
(cl:defmethod has-file-format ((self module))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-file-format))

(cl:unless (cl:fboundp 'clear-file-format)
  (cl:defgeneric clear-file-format (proto)))
(cl:defmethod clear-file-format ((self module))
  (cl:setf (cl:slot-value self 'file-format) proto-v0::+file-format-format-undefined+)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-file-format))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'isa-id))


(cl:defmethod (cl:setf isa-id) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-isa-id)
  (cl:defgeneric has-isa-id (proto)))
(cl:defmethod has-isa-id ((self module))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-isa-id))

(cl:unless (cl:fboundp 'clear-isa-id)
  (cl:defgeneric clear-isa-id (proto)))
(cl:defmethod clear-isa-id ((self module))
  (cl:setf (cl:slot-value self 'isa-id) proto-v0::+isaid-isa-undefined+)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-isa-id))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'name))


(cl:defmethod (cl:setf name) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-name)
  (cl:defgeneric has-name (proto)))
(cl:defmethod has-name ((self module))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-name))

(cl:unless (cl:fboundp 'clear-name)
  (cl:defgeneric clear-name (proto)))
(cl:defmethod clear-name ((self module))
  (cl:setf (cl:slot-value self 'name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-name))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'image-byte-map))

(cl:unless (cl:fboundp 'image-byte-map)
  (cl:defgeneric image-byte-map (proto)))
(cl:defmethod image-byte-map ((self module))
  (cl:let ((result (cl:slot-value self 'image-byte-map)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'proto-v0::image-byte-map))
      (cl:setf (cl:slot-value self 'image-byte-map) result))
      (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf image-byte-map) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-image-byte-map)
  (cl:defgeneric has-image-byte-map (proto)))
(cl:defmethod has-image-byte-map ((self module))
  (cl:logbitp 7 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-image-byte-map))

(cl:unless (cl:fboundp 'clear-image-byte-map)
  (cl:defgeneric clear-image-byte-map (proto)))
(cl:defmethod clear-image-byte-map ((self module))
  (cl:setf (cl:slot-value self 'image-byte-map) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-image-byte-map))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'symbols))

(cl:unless (cl:fboundp 'clear-symbols)
  (cl:defgeneric clear-symbols (proto)))
(cl:defmethod clear-symbols ((self module))
  (cl:setf (cl:slot-value self 'symbols)
           (cl:make-array 0 :element-type 'proto-v0::symbol
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-symbols))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'cfg))

(cl:unless (cl:fboundp 'cfg)
  (cl:defgeneric cfg (proto)))
(cl:defmethod cfg ((self module))
  (cl:let ((result (cl:slot-value self 'cfg)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'proto-v0::cfg))
      (cl:setf (cl:slot-value self 'cfg) result))
      (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf cfg) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-cfg)
  (cl:defgeneric has-cfg (proto)))
(cl:defmethod has-cfg ((self module))
  (cl:logbitp 9 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-cfg))

(cl:unless (cl:fboundp 'clear-cfg)
  (cl:defgeneric clear-cfg (proto)))
(cl:defmethod clear-cfg ((self module))
  (cl:setf (cl:slot-value self 'cfg) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-cfg))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'blocks))

(cl:unless (cl:fboundp 'clear-blocks)
  (cl:defgeneric clear-blocks (proto)))
(cl:defmethod clear-blocks ((self module))
  (cl:setf (cl:slot-value self 'blocks)
           (cl:make-array 0 :element-type 'proto-v0::block
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-blocks))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'data))

(cl:unless (cl:fboundp 'clear-data)
  (cl:defgeneric clear-data (proto)))
(cl:defmethod clear-data ((self module))
  (cl:setf (cl:slot-value self 'data)
           (cl:make-array 0 :element-type 'proto-v0::data-object
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-data))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'proxies))

(cl:unless (cl:fboundp 'clear-proxies)
  (cl:defgeneric clear-proxies (proto)))
(cl:defmethod clear-proxies ((self module))
  (cl:setf (cl:slot-value self 'proxies)
           (cl:make-array 0 :element-type 'proto-v0::proxy-block
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-proxies))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'sections))

(cl:unless (cl:fboundp 'clear-sections)
  (cl:defgeneric clear-sections (proto)))
(cl:defmethod clear-sections ((self module))
  (cl:setf (cl:slot-value self 'sections)
           (cl:make-array 0 :element-type 'proto-v0::section
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-sections))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'symbolic-operands))

(cl:unless (cl:fboundp 'clear-symbolic-operands)
  (cl:defgeneric clear-symbolic-operands (proto)))
(cl:defmethod clear-symbolic-operands ((self module))
  (cl:setf (cl:slot-value self 'symbolic-operands)
           (cl:make-array 0 :element-type 'proto-v0::module-symbolic-operands-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-symbolic-operands))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'aux-data-container))

(cl:unless (cl:fboundp 'aux-data-container)
  (cl:defgeneric aux-data-container (proto)))
(cl:defmethod aux-data-container ((self module))
  (cl:let ((result (cl:slot-value self 'aux-data-container)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'proto-v0::aux-data-container))
      (cl:setf (cl:slot-value self 'aux-data-container) result))
      (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf aux-data-container) :after (x (self module))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-aux-data-container)
  (cl:defgeneric has-aux-data-container (proto)))
(cl:defmethod has-aux-data-container ((self module))
  (cl:logbitp 15 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-aux-data-container))

(cl:unless (cl:fboundp 'clear-aux-data-container)
  (cl:defgeneric clear-aux-data-container (proto)))
(cl:defmethod clear-aux-data-container ((self module))
  (cl:setf (cl:slot-value self 'aux-data-container) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-aux-data-container))


(cl:defmethod cl:print-object ((self module-symbolic-operands-entry) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self module-symbolic-operands-entry))
  (cl:setf (cl:slot-value self 'key) 0)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'value) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self module-symbolic-operands-entry))
  cl:t)

(cl:defmethod pb:octet-size ((self module-symbolic-operands-entry))
  (cl:let ((size 0))
    ;; uint64 key = 1[json_name = "key"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'key)))))
    ;; .protoV0.SymbolicExpression value = 2[json_name = "value"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'value))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self module-symbolic-operands-entry) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; uint64 key = 1[json_name = "key"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'key))))
  ;; .protoV0.SymbolicExpression value = 2[json_name = "value"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'value) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'value) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self module-symbolic-operands-entry) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; uint64 key = 1[json_name = "key"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-uint64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'key) value)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; .protoV0.SymbolicExpression value = 2[json_name = "value"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:slot-value self 'value)))
                  (cl:when (cl:null message)
                    (cl:setf message (cl:make-instance 'proto-v0::symbolic-expression))
                    (cl:setf (cl:slot-value self 'value) message)
                    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment)))))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index
            (wire-format:skip-field field-number wire-type buffer index limit))
          )))))

(cl:defmethod pb:merge-from-message ((self module-symbolic-operands-entry) (from module-symbolic-operands-entry))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'value)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'proto-v0::symbolic-expression))
        (cl:setf (cl:slot-value self 'value) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'value))))
)



(cl:defmethod cl:print-object ((self module) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_uuid: ~s" (uuid self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_binary-path: ~s" (binary-path self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_preferred-addr: ~s" (preferred-addr self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_rebase-delta: ~s" (rebase-delta self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_file-format: ~s" (file-format self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_isa-id: ~s" (isa-id self)))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_name: ~s" (name self)))
      (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_image-byte-map: ~s" (image-byte-map self)))
      (cl:format stream " ~_symbols: ~s" (symbols self))
      (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_cfg: ~s" (cfg self)))
      (cl:format stream " ~_blocks: ~s" (blocks self))
      (cl:format stream " ~_data: ~s" (data self))
      (cl:format stream " ~_proxies: ~s" (proxies self))
      (cl:format stream " ~_sections: ~s" (sections self))
      (cl:format stream " ~_symbolic-operands: ~s" (symbolic-operands self))
      (cl:when (cl:logbitp 15 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_aux-data-container: ~s" (aux-data-container self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self module))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'uuid) (cl:make-array 0 :element-type '(cl:unsigned-byte 8))))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'binary-path) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'preferred-addr) 0)
  (cl:setf (cl:slot-value self 'rebase-delta) 0)
  (cl:setf (cl:slot-value self 'file-format) proto-v0::+file-format-format-undefined+)
  (cl:setf (cl:slot-value self 'isa-id) proto-v0::+isaid-isa-undefined+)
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (pb:string-field "")))
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'image-byte-map) cl:nil))
  (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'cfg) cl:nil))
  (cl:when (cl:logbitp 15 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'aux-data-container) cl:nil))
  (cl:setf (cl:slot-value self 'symbols)
           (cl:make-array 0 :element-type 'proto-v0::symbol
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'blocks)
           (cl:make-array 0 :element-type 'proto-v0::block
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'data)
           (cl:make-array 0 :element-type 'proto-v0::data-object
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'proxies)
           (cl:make-array 0 :element-type 'proto-v0::proxy-block
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'sections)
           (cl:make-array 0 :element-type 'proto-v0::section
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'symbolic-operands)
           (cl:make-array 0 :element-type 'proto-v0::module-symbolic-operands-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self module))
  cl:t)

(cl:defmethod pb:octet-size ((self module))
  (cl:let ((size 0))
    ;; bytes uuid = 1[json_name = "uuid"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'uuid))))
        (cl:+ s (varint:length32 s)))))
    ;; string binary_path = 2[json_name = "binaryPath"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'binary-path))))
        (cl:+ s (varint:length32 s)))))
    ;; uint64 preferred_addr = 3[json_name = "preferredAddr"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'preferred-addr)))))
    ;; int64 rebase_delta = 4[json_name = "rebaseDelta"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'rebase-delta))))))
    ;; .protoV0.FileFormat file_format = 5[json_name = "fileFormat"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'file-format)))))
    ;; .protoV0.ISAID isa_id = 6[json_name = "isaId"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'isa-id)))))
    ;; string name = 7[json_name = "name"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'name))))
        (cl:+ s (varint:length32 s)))))
    ;; .protoV0.ImageByteMap image_byte_map = 8[json_name = "imageByteMap"];
    (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'image-byte-map))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .protoV0.CFG cfg = 10[json_name = "cfg"];
    (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'cfg))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .protoV0.AuxDataContainer aux_data_container = 14[json_name = "auxDataContainer"];
    (cl:when (cl:logbitp 15 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'aux-data-container))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .protoV0.Symbol symbols = 9[json_name = "symbols"];
    (cl:let* ((v (cl:slot-value self 'symbols))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .protoV0.Block blocks = 15[json_name = "blocks"];
    (cl:let* ((v (cl:slot-value self 'blocks))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .protoV0.DataObject data = 11[json_name = "data"];
    (cl:let* ((v (cl:slot-value self 'data))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .protoV0.ProxyBlock proxies = 16[json_name = "proxies"];
    (cl:let* ((v (cl:slot-value self 'proxies))
              (length (cl:length v)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .protoV0.Section sections = 12[json_name = "sections"];
    (cl:let* ((v (cl:slot-value self 'sections))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; map<uint64, .protoV0.SymbolicExpression> symbolic_operands = 13[json_name = "symbolicOperands"];
    (cl:let* ((v (cl:slot-value self 'symbolic-operands))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self module) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; bytes uuid = 1[json_name = "uuid"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'uuid))))
  ;; string binary_path = 2[json_name = "binaryPath"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'binary-path) 'pb::%octets%))))
  ;; uint64 preferred_addr = 3[json_name = "preferredAddr"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'preferred-addr))))
  ;; int64 rebase_delta = 4[json_name = "rebaseDelta"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'rebase-delta)))))
  ;; .protoV0.FileFormat file_format = 5[json_name = "fileFormat"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'file-format)))))
  ;; .protoV0.ISAID isa_id = 6[json_name = "isaId"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'isa-id)))))
  ;; string name = 7[json_name = "name"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'name) 'pb::%octets%))))
  ;; .protoV0.ImageByteMap image_byte_map = 8[json_name = "imageByteMap"];
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 66))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'image-byte-map) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'image-byte-map) buffer index limit)))
  ;; repeated .protoV0.Symbol symbols = 9[json_name = "symbols"];
  (cl:let* ((v (cl:slot-value self 'symbols))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 74))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; .protoV0.CFG cfg = 10[json_name = "cfg"];
  (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 82))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'cfg) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'cfg) buffer index limit)))
  ;; repeated .protoV0.DataObject data = 11[json_name = "data"];
  (cl:let* ((v (cl:slot-value self 'data))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 90))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .protoV0.Section sections = 12[json_name = "sections"];
  (cl:let* ((v (cl:slot-value self 'sections))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 98))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; map<uint64, .protoV0.SymbolicExpression> symbolic_operands = 13[json_name = "symbolicOperands"];
  (cl:let* ((v (cl:slot-value self 'symbolic-operands))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 106))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; .protoV0.AuxDataContainer aux_data_container = 14[json_name = "auxDataContainer"];
  (cl:when (cl:logbitp 15 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 114))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'aux-data-container) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'aux-data-container) buffer index limit)))
  ;; repeated .protoV0.Block blocks = 15[json_name = "blocks"];
  (cl:let* ((v (cl:slot-value self 'blocks))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 122))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .protoV0.ProxyBlock proxies = 16[json_name = "proxies"];
  (cl:let* ((v (cl:slot-value self 'proxies))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 130))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self module) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; bytes uuid = 1[json_name = "uuid"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'uuid) value)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; string binary_path = 2[json_name = "binaryPath"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'binary-path) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; uint64 preferred_addr = 3[json_name = "preferredAddr"];
        ((3)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-uint64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'preferred-addr) value)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; int64 rebase_delta = 4[json_name = "rebaseDelta"];
        ((4)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'rebase-delta) value)
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; .protoV0.FileFormat file_format = 5[json_name = "fileFormat"];
        ((5)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int32-carefully buffer index limit)
                ;; XXXXX: when valid, set field, else add to unknown fields
                (cl:setf (cl:slot-value self 'file-format) value)
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; .protoV0.ISAID isa_id = 6[json_name = "isaId"];
        ((6)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int32-carefully buffer index limit)
                ;; XXXXX: when valid, set field, else add to unknown fields
                (cl:setf (cl:slot-value self 'isa-id) value)
                (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; string name = 7[json_name = "name"];
        ((7)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'name) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; .protoV0.ImageByteMap image_byte_map = 8[json_name = "imageByteMap"];
        ((8)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:slot-value self 'image-byte-map)))
                  (cl:when (cl:null message)
                    (cl:setf message (cl:make-instance 'proto-v0::image-byte-map))
                    (cl:setf (cl:slot-value self 'image-byte-map) message)
                    (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated .protoV0.Symbol symbols = 9[json_name = "symbols"];
        ((9)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:make-instance 'proto-v0::symbol)))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment))
                  (cl:vector-push-extend message (cl:slot-value self 'symbols)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; .protoV0.CFG cfg = 10[json_name = "cfg"];
        ((10)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:slot-value self 'cfg)))
                  (cl:when (cl:null message)
                    (cl:setf message (cl:make-instance 'proto-v0::cfg))
                    (cl:setf (cl:slot-value self 'cfg) message)
                    (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated .protoV0.DataObject data = 11[json_name = "data"];
        ((11)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:make-instance 'proto-v0::data-object)))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment))
                  (cl:vector-push-extend message (cl:slot-value self 'data)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated .protoV0.Section sections = 12[json_name = "sections"];
        ((12)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:make-instance 'proto-v0::section)))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment))
                  (cl:vector-push-extend message (cl:slot-value self 'sections)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; map<uint64, .protoV0.SymbolicExpression> symbolic_operands = 13[json_name = "symbolicOperands"];
        ((13)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:make-instance 'proto-v0::module-symbolic-operands-entry)))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment))
                  (cl:vector-push-extend message (cl:slot-value self 'symbolic-operands)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; .protoV0.AuxDataContainer aux_data_container = 14[json_name = "auxDataContainer"];
        ((14)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:slot-value self 'aux-data-container)))
                  (cl:when (cl:null message)
                    (cl:setf message (cl:make-instance 'proto-v0::aux-data-container))
                    (cl:setf (cl:slot-value self 'aux-data-container) message)
                    (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 1))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated .protoV0.Block blocks = 15[json_name = "blocks"];
        ((15)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:make-instance 'proto-v0::block)))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment))
                  (cl:vector-push-extend message (cl:slot-value self 'blocks)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated .protoV0.ProxyBlock proxies = 16[json_name = "proxies"];
        ((16)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:make-instance 'proto-v0::proxy-block)))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment))
                  (cl:vector-push-extend message (cl:slot-value self 'proxies)))))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index
            (wire-format:skip-field field-number wire-type buffer index limit))
          )))))

(cl:defmethod pb:merge-from-message ((self module) (from module))
  (cl:let* ((v (cl:slot-value self 'symbols))
            (vf (cl:slot-value from 'symbols))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'blocks))
            (vf (cl:slot-value from 'blocks))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'data))
            (vf (cl:slot-value from 'data))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'proxies))
            (vf (cl:slot-value from 'proxies))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'sections))
            (vf (cl:slot-value from 'sections))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'symbolic-operands))
            (vf (cl:slot-value from 'symbolic-operands))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'uuid) (cl:slot-value from 'uuid))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'binary-path) (cl:slot-value from 'binary-path))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'preferred-addr) (cl:slot-value from 'preferred-addr))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'rebase-delta) (cl:slot-value from 'rebase-delta))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'file-format) (cl:slot-value from 'file-format))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'isa-id) (cl:slot-value from 'isa-id))
    (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (cl:slot-value from 'name))
    (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 7 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'image-byte-map)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'proto-v0::image-byte-map))
        (cl:setf (cl:slot-value self 'image-byte-map) message)
        (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'image-byte-map))))
  (cl:when (cl:logbitp 9 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'cfg)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'proto-v0::cfg))
        (cl:setf (cl:slot-value self 'cfg) message)
        (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'cfg))))
  (cl:when (cl:logbitp 15 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'aux-data-container)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'proto-v0::aux-data-container))
        (cl:setf (cl:slot-value self 'aux-data-container) message)
        (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'aux-data-container))))
)


