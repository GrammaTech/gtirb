<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GTIRB: stack-stamp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GTIRB
   &#160;<span id="projectnumber">v1.10.4</span>
   </div>
   <div id="projectbrief">GrammaTech Intermediate Representation for Binaries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">stack-stamp </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md214">GTIRB Stack Stamp</a><ul><li class="level2"><a href="#autotoc_md215">A. Install all required libraries and utilities</a></li>
<li class="level2"><a href="#autotoc_md216">B. Lift a binary to GTIRB</a></li>
<li class="level2"><a href="#autotoc_md217">C.a Implement your own stack-stamp transform</a></li>
<li class="level2"><a href="#autotoc_md218">C.b Just run our stack-stamp transform</a></li>
<li class="level2"><a href="#autotoc_md219">D. Serialize GTIRB to a new executable and test</a></li>
<li class="level2"><a href="#autotoc_md220">E. Visualize the difference using gtirb-ghidra-plugin</a><ul><li class="level3"><a href="#autotoc_md221">a. Install prerequisites if they are not already installed</a></li>
<li class="level3"><a href="#autotoc_md222">b. Import and analyze the files</a></li>
<li class="level3"><a href="#autotoc_md223">c. Use the Version Tracking tool to match function locations</a></li>
<li class="level3"><a href="#autotoc_md224">d. Examine the changes in a side-by-side view</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md214"></a>
GTIRB Stack Stamp</h1>
<p><a class="anchor" id="gtirb-stack-stamp"></a></p>
<p>TLDR; It is very easy to write binary transforms in GTIRB, see <a href="https://github.com/grammatech/gtirb-stack-stamp">gtirb-stack-stamp</a>.</p>
<p>This tutorial demonstrates the development of a binary hardening transform built on <a href="https://grammatech.github.io/gtirb">GTIRB</a> (a data structure that represents binary executables). We implement <em>stack stamping</em> (a simple return oriented programming, or ROP, defense) as a GTIRB-to-GTIRB transformation. We leverage the <a href="https://github.com/grammatech/ddisasm">ddisasm</a> front-end to disassemble binaries to GTIRB and the <a href="https://github.com/grammatech/gtirb-pprinter">gtirb-pprinter</a> back-end to produce a new hardened executable from the stack stamped GTIRB. In practice the stack-stamp transform could be chained with other GTIRB binary analysis or transformation passes. Implementations of the stack stamping transform are given in all three GTIRB API languages; Python <a href="https://grammatech.github.io/gtirb/python/index.html">API</a>/<a href="https://github.com/GrammaTech/gtirb-stack-stamp/blob/master/gtirb_stack_stamp/stack_stamp.py">stack_stamp.py</a>, C++ <a href="https://grammatech.github.io/gtirb/cpp/index.html">API</a>/<a href="https://github.com/GrammaTech/gtirb-stack-stamp/blob/master/include/gtirb_stack_stamp.hpp">gtirb_stack_stamp.hpp</a>, and Common Lisp <a href="https://grammatech.github.io/gtirb/cl/index.html">API</a>/<a href="https://github.com/GrammaTech/gtirb-stack-stamp/blob/master/gtirb-stack-stamp.lisp">gtirb-stack-stamp.lisp</a>.</p>
<p>This document walks through the whole process of writing and applying the <em>stack stamping</em> binary ROP protection in following steps:</p>
<ul>
<li>A. <a href="#a-install-all-required-libraries-and-utilities">Install Dependencies</a></li>
<li>B. <a href="#b-lift-a-binary-to-gtirb">Lift a binary to GTIRB</a></li>
<li>C.a <a href="#ca-implement-your-own-stack-stamp-transform">Implement your own stack-stamp transform</a></li>
<li>C.b <a href="#cb-just-run-our-stack-stamp-transform">Just run our stack-stamp transform</a></li>
<li>D. <a href="#d-serialize-gtirb-to-a-new-executable-and-test">Serialize GTIRB to a new executable and test</a></li>
<li>E. <a href="#e-visualize-the-difference-using-gtirb-ghidra-plugin">Visualize the difference using the gtirb-ghidra-plugin</a></li>
<li>F. Let us know what you think. You can open an issue against <a href="https://github.com/grammatech/gtirb">github.com/grammatech/gtirb</a> or email us at <code>gtirb@grammatech.com</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md215"></a>
A. Install all required libraries and utilities</h2>
<p><a class="anchor" id="a.-install-all-required-libraries-and-utilities"></a></p>
<p>The following should be sufficient to install the required GTIRB libraries and utilities (for complete installation instructions see <a href="https://github.com/grammatech/gtirb#installing">GTIRB::Install</a>).</p>
<ol type="1">
<li>Install the required binaries.<ul>
<li><p class="startli">Windows:</p>
<p class="startli">&gt; NOTE: Windows users are warned that (1) you can't assemble and &gt; link your rewritten ELF file on Windows unless you have the &gt; required Linux build tool installed (2) the Common Lisp APIs &gt; are not tested on Windows &ndash; although they might work.</p><ol type="a">
<li>Download <code>ddisasm-artifacts.zip</code>, <code>gtirb-artifacts.zip</code>, and <code>gtirb-pprinter-artifacts.zip</code> from <a href="https://grammatech.github.io/gtirb/pkgs/windows-release">https://grammatech.github.io/gtirb/pkgs/windows-release</a>;</li>
<li>Extract each ZIP file to a suitable location.</li>
<li>Add the /bin directory from each extracted ZIP file to your <code>PATH</code> environment variable. (Alternatively, provide the full path when you invoke the extracted executables.)</li>
<li>If it is not already present on your system, install <a href="https://developers.google.com/protocol-buffers/">Protobuf</a> version 3.0.0 or higher.</li>
<li>If you plan to work in C++, you will also need <a href="https://www.boost.org/">Boost</a>, version 1.67.0 or higher.</li>
</ol>
</li>
<li>Ubuntu16: install the binaries from the GTIRB xenial repository as follows. <pre class="fragment">sudo apt-get install software-properties-common
sudo add-apt-repository ppa:maarten-fonville/protobuf
sudo add-apt-repository ppa:mhier/libboost-latest
echo "deb https://grammatech.github.io/gtirb/pkgs/xenial ./" | sudo tee -a /etc/apt/sources.list.d/gtirb.list
sudo apt-get update
sudo apt-get install --allow-unauthenticated libgtirb-dev gtirb-pprinter ddisasm
</pre></li>
<li>Ubuntu18: install the binaries from the GTIRB bionic repository as follows. <pre class="fragment">sudo apt-get install software-properties-common
sudo add-apt-repository ppa:mhier/libboost-latest
echo "deb [trusted=yes] https://grammatech.github.io/gtirb/pkgs/bionic ./" | sudo tee -a /etc/apt/sources.list.d/gtirb.list
sudo apt-get update
sudo apt-get install libgtirb-dev gtirb-pprinter ddisasm
</pre></li>
<li>Ubuntu20: install the binaries from the GTIRB focal repository as follows. <pre class="fragment">sudo apt-get install software-properties-common
echo "deb [trusted=yes] https://grammatech.github.io/gtirb/pkgs/focal ./" | sudo tee -a /etc/apt/sources.list.d/gtirb.list
sudo apt-get update
sudo apt-get install libgtirb-dev gtirb-pprinter ddisasm
</pre></li>
<li>Arch Linux: install pre-built <code>pacman</code> packages from <a href="https://grammatech.github.io/gtirb/pkgs/arch">https://grammatech.github.io/gtirb/pkgs/arch</a> or install using the popular <a href="https://wiki.archlinux.org/index.php/AUR_helpers">aur helper</a> <a href="https://github.com/Jguer/yay">yay</a>, <pre class="fragment">yay -Sy gtirb-git gtirb-pprinter-git ddisasm-git
</pre></li>
</ul>
</li>
<li>For the Common Lisp and C++ API, install <a href="https://github.com/keystone-engine/keystone">Keystone</a>. Keystone does not have prebuilt packages, so you must install this from source. For Linux systems, this generally looks like: <pre class="fragment">git clone https://github.com/keystone-engine/keystone.git
cd keystone
mkdir build
cd build
../make-share.sh
make install
</pre></li>
<li>Make sure the required GTIRB components are available to your development environment. This will depend on the language you want to work in:<ul>
<li>C++: when you compile your transform, do all of the following.<ul>
<li>Specify that the GTIRB <code>lib/</code> is a library directory.</li>
<li>Specify that the GTIRB <code>include/</code> is an include directory.</li>
<li>Link against the <code>gtirb</code> and <code>proto</code> libraries (Windows: <code>gtirb.lib</code>, <code>proto.lib</code>; Linux: <code>gtirb.so</code>, <code>proto.so</code>).</li>
</ul>
</li>
<li>Python (note: must be Python 3): <pre class="fragment">pip3 install gtirb gtirb-functions gtirb-capstone
</pre></li>
<li>Common Lisp:<ol type="a">
<li>Clone the latest versions of these repositories into your <code>~/quicklisp/local-projects</code> directory (the versions in quicklisp don't yet have some important bugfixes) <pre class="fragment">cd ~/quicklisp/local-projects
git clone https://github.com/brown/protobuf
git clone --single-branch --branch quicklisp https://github.com/grammatech/gtirb
git clone https://github.com/grammatech/gtirb-capstone
git clone https://github.com/grammatech/gtirb-functions
</pre></li>
<li>Install with quicklisp. <pre class="fragment">(ql:quickload '(:gtirb :gtirb-functions :gtirb-capstone))
</pre></li>
</ol>
</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md216"></a>
B. Lift a binary to GTIRB</h2>
<p><a class="anchor" id="b.-lift-a-binary-to-gtirb"></a></p>
<p>GrammaTech's open-source GTIRB tooling supports disassembly of ELF binaries only.</p>
<p>The example used in this tutorial is a Linux <code>ls</code> binary. If you prefer, you can work with a different ELF binary: just amend the command lines as necessary to accommodate any file name differences.</p>
<p>If you are on a Linux system, you can analyze your system <code>ls</code>. For Windows users, we have provided additional instructions for obtaining a Linux <code>ls</code> binary.</p>
<p>Ubuntu 16, Ubuntu18, Ubuntu20, Arch Linux:</p>
<ol type="1">
<li>Change to a suitable working directory.</li>
<li>Run the datalog disassembler to analyze the binary and produce a GTIRB representation.</li>
</ol>
<pre class="fragment">     ddisasm $(which ls) --ir ls.gtirb
</pre><p>Windows:</p>
<ol type="1">
<li>Do you have easy access to a Linux <code>ls</code> binary? (For example, can you copy one from another local system?)<ul>
<li>YES: Copy the binary to a suitable working directory and go to step 4.</li>
<li>NO: Go on to step 2.</li>
</ul>
</li>
<li>Download a Linux coreutils package from <a href="http://launchpadlibrarian.net/340091849/coreutils_8.26-3ubuntu4_amd64.deb">http://launchpadlibrarian.net/340091849/coreutils_8.26-3ubuntu4_amd64.deb</a> (or another location if you prefer).</li>
<li><p class="startli">Use a tool such as <a href="https://www.7-zip.org/">7-Zip</a> to extract <code>/bin/ls</code> from the package, then copy it to a suitable working directory.</p>
<p class="startli">(If your tool does not support selective extraction, unpack the entire package to a temporary location, then copy <code>/bin/ls</code> to your working directory.)</p>
</li>
<li>Change to your working directory.</li>
</ol>
<p>If you are not able to successfully analyze your chosen binary, please <a href="https://github.com/GrammaTech/ddisasm/issues/new">open an issue</a> to let us know.</p>
<h2><a class="anchor" id="autotoc_md217"></a>
C.a Implement your own stack-stamp transform</h2>
<p><a class="anchor" id="c.a-implement-your-own-stack-stamp-transform"></a></p>
<p>Stack stamping is a technique to help mitigate ROP style attacks. This is done by 'stamping' (<code>xor</code>ing with a random number) the return address on the stack at the beginning of every function, thus encrypting it. At the end of the function, before the return address is popped off the stack and used, it is decrypted by <code>xor</code>ing it again with the same random number. This can be a very efficient protection. Because it only requires an <code>xor</code> instruction this implementation requires no registers, and while flags are affected, they are only affected at function entry/exits where they do not need to be preserved. The effect of encrypting and decrypting the return address on the stack like this is that ROP payloads become much more difficult to write. The attacker would have to know the random <code>xor</code> number for every return to encrypt the return addresses in the payload. These numbers could easily be regenerated for every instance of a deployed binary making generic payloads impossible.</p>
<p><img src=".stack-stamp.svg" alt="" style="pointer-events: none;" class="inline" title="Stack Stamp Figure"/></p>
<p>Regardless of the implementation language the mechanics of this transform will be the same &ndash; we'll write a GTIRB-to-GTIRB rewriting pass (the design of GTIRB is similar to LLVM in that it leverages stand-alone passes for analysis or transformation).</p>
<pre class="fragment">  For each function f that has a single entry and single return.
     Build a random key k_f for f.
     On entry to f, encrypt the return address using k_f.
     On exit from f, decrypt the return address using k_f.
</pre><ol type="1">
<li><p class="startli">Implement the transform, using the <a href="https://grammatech.github.io/gtirb/">GTIRB manual</a> as a reference.</p>
<p class="startli">If you're developing in Python or Common Lisp you can work directly in a Read Eval Print Loop (REPL), or use it to prototype a stand-alone implementation.</p><ul>
<li>For all languages, start by importing the <code>gtirb</code> API and then loading your <code>ls.gtirb</code> file. For Common Lisp and Python, you will also need to import the <code>gtirb-functions</code> and <code>gtirb-capstone</code> APIs.<ul>
<li>Python <pre class="fragment">from gtirb import *
import gtirb_functions
import gtirb_capstone
ir = IR.load_protobuf("ls.gtirb")
</pre></li>
<li>C++ <pre class="fragment">#include &lt;gtirb.hpp&gt;
gtirb::Context Ctx;
std::ifstream File("ls.gtirb");
gtirb::IR* Ir = *gtirb::IR::load(Ctx, File);
</pre></li>
<li>Common Lisp <pre class="fragment">(mapcar #'use-package '(:gtirb :gtirb-capstone :gtirb-functions))
(defparameter *ir* (read-gtirb "ls.gtirb"))
</pre></li>
</ul>
</li>
<li>The mechanism for identifying functions and their entry points depends on the API language you are using.<ul>
<li>Python: Use the <code>gtirb-functions</code> API functionality (<a href="https://github.com/GrammaTech/gtirb-functions/tree/master/gtirb_functions">Python</a>) to obtain the set of recovered functions, and the sets of entry and exit blocks for each function.</li>
<li>C++: The GTIRB <a href="https://grammatech.github.io/gtirb/md__aux_data.html">sanctioned AuxData tables</a> are populated by <code>ddisasm</code>: use the <code>gtirb</code> API to access the information in these tables.</li>
<li>Common Lisp: Use the <code>gtirb-functions</code> API functionality (<a href="https://github.com/GrammaTech/gtirb-functions/blob/master/gtirb-functions.lisp">Common Lisp</a>) to obtain the set of recovered functions, and the sets of entry and exit blocks for each function.</li>
</ul>
</li>
</ul>
</li>
<li>When you're done, compare your implementation to the corresponding completed transform in the gtirb-stack-stamp repository on GitHub:<ul>
<li><a href="https://github.com/GrammaTech/gtirb-stack-stamp/blob/master/gtirb_stack_stamp/stack_stamp.py#L36">Python</a></li>
<li><a href="https://github.com/GrammaTech/gtirb-stack-stamp/blob/master/src/gtirb_stack_stamp.cpp">C++</a></li>
<li><a href="https://github.com/GrammaTech/gtirb-stack-stamp/blob/master/gtirb-stack-stamp.lisp#L24">Common Lisp</a></li>
</ul>
</li>
<li>Apply your transform to <code>ls.gtirb</code>.</li>
<li>Serialize the transformed GTIRB to a new file <code>ls-ss.gtirb</code>.<ul>
<li>Python <pre class="fragment">ir.save_protobuf("ls-ss.gtirb")
</pre></li>
<li>C++ <pre class="fragment">std::ofstream File("ls-ss.gtirb");
Ir-&gt;save(File);
</pre></li>
<li>Common Lisp <pre class="fragment">(write-gtirb *ir* "ls-ss.gtirb")
</pre></li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md218"></a>
C.b Just run our stack-stamp transform</h2>
<p><a class="anchor" id="c.b-just-run-our-stack-stamp-transform"></a></p>
<p>If you're interested in applying this transform but not writing it yourself you can try our implementation available at <a href="https://github.com/GrammaTech/gtirb-stack-stamp">https://github.com/GrammaTech/gtirb-stack-stamp</a>.</p>
<ul>
<li>Python <pre class="fragment">python setup.py install
python -m gtirb_stack_stamp /tmp/ls.gtirb --outfile /tmp/ls-ss.gtirb --rebuild /tmp/ls-ss
</pre></li>
<li>C++ <pre class="fragment">mkdir build
cmake -Bbuild
make -Cbuild
./build/bin/gtirb-stack-stamp -i /tmp/ls.gtirb -o /tmp/ls-ss.gtirb
</pre></li>
<li>Common Lisp <pre class="fragment">sbcl --eval '(ql:quickload :gtirb-stack-stamp)' --eval '(asdf:make :gtirb-stack-stamp :type :program :monolithic t)'
./stack-stamp -g /tmp/ls-ss.gtirb -b /tmp/ls-ss
</pre></li>
</ul>
<h2><a class="anchor" id="autotoc_md219"></a>
D. Serialize GTIRB to a new executable and test</h2>
<p><a class="anchor" id="d.-serialize-gtirb-to-a-new-executable-and-test"></a></p>
<p>The final step is to use the GTIRB pretty printer to convert your GTIRB representation to a new binary.</p>
<blockquote class="doxtable">
<p>NOTE: Although you can pretty-print GTIRB to assembly on Windows you can't actually assemble or link the assembler to an ELF file on Windows because the required <code>as</code> and <code>ld</code> commands are typically not installed. So this is likely the end of the road for users without access to a Linux machine. </p>
</blockquote>
<ol type="1">
<li>Run the following command.</li>
</ol>
<pre class="fragment">   gtirb-pprinter ls-ss.gtirb --skip-section .eh_frame \
               --asm ls.ss.s \
               --binary ls.ss
</pre><ol type="1">
<li><p class="startli">Try running the new binary. Its behavior should be indistinguishable from the original.</p>
<p class="startli">(You will not be able to do this on Windows. However, if you have access to a Linux system, you can copy your new binary there and try it out.)</p>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md220"></a>
E. Visualize the difference using gtirb-ghidra-plugin</h2>
<p><a class="anchor" id="e.-visualize-the-difference-using-gtirb-ghidra-plugin"></a></p>
<p><a href="https://ghidra-sre.org">Ghidra</a> is a reverse engineering framework developed by the National Security Agency (NSA). With a GTIRB plug-in, Ghidra offers a useful GUI for examining the differences between GTIRB files.</p>
<p>Procedure:</p>
<ul>
<li>a. <a href="#a-install-prerequisites-if-they-are-not-already-installed">Install prerequisites if they are not already installed</a></li>
<li>b. <a href="#b-import-and-analyze-the-files">Import and analyze the files</a></li>
<li>c. <a href="#c-use-the-version-tracking-tool-to-match-function-locations">Use the Version Tracking tool to match function locations</a></li>
<li>d. <a href="#d-examine-the-changes-in-a-side-by-side-view">Examine the changes in a side-by-side view</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md221"></a>
a. Install prerequisites if they are not already installed</h3>
<p><a class="anchor" id="a.-install-prerequisites-if-they-are-not-already-installed"></a></p>
<ol type="1">
<li>Java 11 (a prerequisite for Ghidra): <a href="https://www.linuxbabe.com/ubuntu/install-oracle-java-8-openjdk-11-ubuntu-18-04-18-10">Ubuntu18</a>, <a href="https://access.redhat.com/documentation/en-us/openjdk/11/html/openjdk_11_for_windows_getting_started_guide/index">Windows</a></li>
<li><a href="https://ghidra-sre.org/">Ghidra</a>.</li>
<li>The <a href="https://github.com/GrammaTech/gtirb-ghidra-plugin">GTIRB Ghidra plugin</a>.</li>
</ol>
<h3><a class="anchor" id="autotoc_md222"></a>
b. Import and analyze the files</h3>
<p><a class="anchor" id="b.-import-and-analyze-the-files"></a></p>
<ol type="1">
<li>Start Ghidra and open a project or create a new one.</li>
<li>Import <code>ls.gtirb</code> and double-click it to open a Code Browser.</li>
<li><p class="startli">When prompted to analyze it, hit "Yes" and select "Disassemble
   Entry Points" (only).</p>
<p class="startli">This will populate the listing with disassembly for all functions.</p>
</li>
<li>When the analysis is complete, save the file and close the Code Browser.</li>
<li>Repeat steps 2-4 for <code>ls-ss.gtirb</code></li>
</ol>
<h3><a class="anchor" id="autotoc_md223"></a>
c. Use the Version Tracking tool to match function locations</h3>
<p><a class="anchor" id="c.-use-the-version-tracking-tool-to-match-function-locations"></a></p>
<ol type="1">
<li>Click on the "Footprints" icon to start the Version Tracking tool.</li>
<li>The Version Tracking tool also has a footprints icon, click on this to start a new session wizard.</li>
<li>Enter a session name and select the before and after files as Source and Destination.</li>
<li><p class="startli">Skip the precondition checks and click Finish.</p>
<p class="startli">This will open source and destination tools, which you can minimize as we don't need them.</p>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md224"></a>
d. Examine the changes in a side-by-side view</h3>
<p><a class="anchor" id="d.-examine-the-changes-in-a-side-by-side-view"></a></p>
<ol type="1">
<li>In the Version Tracking tool, click the green "+" (plus sign) to start comparing the files.</li>
<li>In the wizard that comes up, select "Exact Symbol Name Match" (only). This will allow us to do a side-by-side comparison of functions of the same name.</li>
<li><p class="startli">Click Next and Finish.</p>
<p class="startli">The Version Tracking Matches window will be populated with a list of matches. (If you don't see a Version Tracking Matches window, go to Window in the top menu and select Version Tracking Matches).</p>
</li>
<li>Select a function by clicking on a row with type Function.</li>
<li>Go to the Version Tracking Markup window to see a comparison of this function (if you don't see source and destination sections in the Version Tracking Markup window, click the "Book" icon in the upper right corner of the Version Tracking Markup window. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
